# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `active_record_extended` gem.
# Please instead update this file by running `bin/tapioca gem active_record_extended`.

module ActiveRecord
  extend ::ActiveSupport::Autoload

  class << self
    def action_on_strict_loading_violation; end
    def action_on_strict_loading_violation=(_arg0); end
    def application_record_class; end
    def application_record_class=(_arg0); end
    def async_query_executor; end
    def async_query_executor=(_arg0); end
    def default_timezone; end
    def default_timezone=(default_timezone); end
    def dump_schema_after_migration; end
    def dump_schema_after_migration=(_arg0); end
    def dump_schemas; end
    def dump_schemas=(_arg0); end
    def eager_load!; end
    def error_on_ignored_order; end
    def error_on_ignored_order=(_arg0); end
    def gem_version; end
    def global_executor_concurrency; end
    def global_executor_concurrency=(global_executor_concurrency); end
    def global_thread_pool_async_query_executor; end
    def index_nested_attribute_errors; end
    def index_nested_attribute_errors=(_arg0); end
    def lazily_load_schema_cache; end
    def lazily_load_schema_cache=(_arg0); end
    def legacy_connection_handling; end
    def legacy_connection_handling=(_arg0); end
    def maintain_test_schema; end
    def maintain_test_schema=(_arg0); end
    def query_transformers; end
    def query_transformers=(_arg0); end
    def queues; end
    def queues=(_arg0); end
    def reading_role; end
    def reading_role=(_arg0); end
    def schema_cache_ignored_tables; end
    def schema_cache_ignored_tables=(_arg0); end
    def schema_format; end
    def schema_format=(_arg0); end
    def suppress_multiple_database_warning; end
    def suppress_multiple_database_warning=(_arg0); end
    def timestamped_migrations; end
    def timestamped_migrations=(_arg0); end
    def verbose_query_logs; end
    def verbose_query_logs=(_arg0); end
    def verify_foreign_keys_for_fixtures; end
    def verify_foreign_keys_for_fixtures=(_arg0); end
    def version; end
    def warn_on_records_fetched_greater_than; end
    def warn_on_records_fetched_greater_than=(_arg0); end
    def writing_role; end
    def writing_role=(_arg0); end
  end
end

class ActiveRecord::MigrationProxy < ::Struct
  def initialize(name, version, filename, scope); end

  def announce(*_arg0, **_arg1, &_arg2); end
  def basename; end
  def disable_ddl_transaction(*_arg0, **_arg1, &_arg2); end
  def filename; end
  def filename=(_); end
  def migrate(*_arg0, **_arg1, &_arg2); end
  def name; end
  def name=(_); end
  def scope; end
  def scope=(_); end
  def version; end
  def version=(_); end
  def write(*_arg0, **_arg1, &_arg2); end

  private

  def load_migration; end
  def migration; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::Point < ::Struct
  def x; end
  def x=(_); end
  def y; end
  def y=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection

  def _select!(*fields); end
  def and(other); end
  def and!(other); end
  def annotate(*args); end
  def annotate!(*args); end
  def annotate_values; end
  def annotate_values=(value); end
  def arel(aliases = T.unsafe(nil)); end
  def construct_join_dependency(associations, join_type); end
  def create_with(value); end
  def create_with!(value); end
  def create_with_value; end
  def create_with_value=(value); end
  def distinct(value = T.unsafe(nil)); end
  def distinct!(value = T.unsafe(nil)); end
  def distinct_value; end
  def distinct_value=(value); end
  def eager_load(*args); end
  def eager_load!(*args); end
  def eager_load_values; end
  def eager_load_values=(value); end
  def excluding(*records); end
  def excluding!(records); end
  def extending(*modules, &block); end
  def extending!(*modules, &block); end
  def extending_values; end
  def extending_values=(value); end
  def extensions; end
  def extract_associated(association); end
  def from(value, subquery_name = T.unsafe(nil)); end
  def from!(value, subquery_name = T.unsafe(nil)); end
  def from_clause; end
  def from_clause=(value); end
  def group(*args); end
  def group!(*args); end
  def group_values; end
  def group_values=(value); end
  def having(opts, *rest); end
  def having!(opts, *rest); end
  def having_clause; end
  def having_clause=(value); end
  def in_order_of(column, values); end
  def includes(*args); end
  def includes!(*args); end
  def includes_values; end
  def includes_values=(value); end
  def invert_where; end
  def invert_where!; end
  def joins(*args); end
  def joins!(*args); end
  def joins_values; end
  def joins_values=(value); end
  def left_joins(*args); end
  def left_outer_joins(*args); end
  def left_outer_joins!(*args); end
  def left_outer_joins_values; end
  def left_outer_joins_values=(value); end
  def limit(value); end
  def limit!(value); end
  def limit_value; end
  def limit_value=(value); end
  def lock(locks = T.unsafe(nil)); end
  def lock!(locks = T.unsafe(nil)); end
  def lock_value; end
  def lock_value=(value); end
  def none; end
  def none!; end
  def offset(value); end
  def offset!(value); end
  def offset_value; end
  def offset_value=(value); end
  def optimizer_hints(*args); end
  def optimizer_hints!(*args); end
  def optimizer_hints_values; end
  def optimizer_hints_values=(value); end
  def or(other); end
  def or!(other); end
  def order(*args); end
  def order!(*args); end
  def order_values; end
  def order_values=(value); end
  def preload(*args); end
  def preload!(*args); end
  def preload_values; end
  def preload_values=(value); end
  def readonly(value = T.unsafe(nil)); end
  def readonly!(value = T.unsafe(nil)); end
  def readonly_value; end
  def readonly_value=(value); end
  def references(*table_names); end
  def references!(*table_names); end
  def references_values; end
  def references_values=(value); end
  def reorder(*args); end
  def reorder!(*args); end
  def reordering_value; end
  def reordering_value=(value); end
  def reselect(*args); end
  def reselect!(*args); end
  def reverse_order; end
  def reverse_order!; end
  def reverse_order_value; end
  def reverse_order_value=(value); end
  def rewhere(conditions); end
  def select(*fields); end
  def select_values; end
  def select_values=(value); end
  def skip_preloading!; end
  def skip_query_cache!(value = T.unsafe(nil)); end
  def skip_query_cache_value; end
  def skip_query_cache_value=(value); end
  def strict_loading(value = T.unsafe(nil)); end
  def strict_loading!(value = T.unsafe(nil)); end
  def strict_loading_value; end
  def strict_loading_value=(value); end
  def structurally_compatible?(other); end
  def uniq!(name); end
  def unscope(*args); end
  def unscope!(*args); end
  def unscope_values; end
  def unscope_values=(value); end
  def where(*args); end
  def where!(opts, *rest); end
  def where_clause; end
  def where_clause=(value); end
  def without(*records); end

  protected

  def build_having_clause(opts, rest = T.unsafe(nil)); end
  def build_subquery(subquery_alias, select_value); end
  def build_where_clause(opts, rest = T.unsafe(nil)); end

  private

  def arel_column(field); end
  def arel_columns(columns); end
  def assert_mutability!; end
  def build_arel(aliases = T.unsafe(nil)); end
  def build_cast_value(name, value); end
  def build_from; end
  def build_join_buckets; end
  def build_join_dependencies; end
  def build_joins(join_sources, aliases = T.unsafe(nil)); end
  def build_order(arel); end
  def build_select(arel); end
  def check_if_method_has_arguments!(method_name, args, message = T.unsafe(nil)); end
  def column_references(order_args); end
  def does_not_support_reverse?(order); end
  def each_join_dependencies(join_dependencies = T.unsafe(nil), &block); end
  def lookup_table_klass_from_join_dependencies(table_name); end
  def order_column(field); end
  def preprocess_order_args(order_args); end
  def resolve_arel_attributes(attrs); end
  def reverse_sql_order(order_query); end
  def sanitize_order_arguments(order_args); end
  def select_association_list(associations, stashed_joins = T.unsafe(nil)); end
  def structurally_incompatible_values_for(other); end
  def table_name_matches?(from); end
  def validate_order_args(args); end
end

ActiveRecord::QueryMethods::FROZEN_EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
ActiveRecord::QueryMethods::FROZEN_EMPTY_HASH = T.let(T.unsafe(nil), Hash)
ActiveRecord::QueryMethods::STRUCTURAL_VALUE_METHODS = T.let(T.unsafe(nil), Array)
ActiveRecord::QueryMethods::VALID_DIRECTIONS = T.let(T.unsafe(nil), Set)
ActiveRecord::QueryMethods::VALID_UNSCOPING_VALUES = T.let(T.unsafe(nil), Set)

class ActiveRecord::QueryMethods::WhereChain
  include ::ActiveRecordExtended::WhereChain
  include ::ActiveRecordExtended::QueryMethods::AnyOf
  include ::ActiveRecordExtended::QueryMethods::Inet

  def initialize(scope); end

  def associated(*associations); end
  def build_where_chain(opts, rest, &block); end
  def missing(*associations); end
  def not(opts, *rest); end

  private

  def scope_association_reflection(association); end
end

ActiveRecord::UnknownAttributeError = ActiveModel::UnknownAttributeError
module ActiveRecordExtended; end

module ActiveRecordExtended::ArrayHandlerDecorator
  def call(attribute, value); end
end

module ActiveRecordExtended::QueryMethods; end

module ActiveRecordExtended::QueryMethods::AnyOf
  def any_of(*queries); end
  def none_of(*queries); end

  private

  # Rails 5.1 fix
  # In Rails 5.2 the arel table maintains attribute binds
  def bind_attributes(query); end

  def build_query(queries); end
  def construct_query_mappings(queries); end
  def generate_where_clause(query); end
  def hash_map_queries(queries); end
  def translate_reference(reference); end

  # Rails 5.1 fix
  def unprepared_query(query); end
end

module ActiveRecordExtended::QueryMethods::Either
  def either_join(initial_association, fallback_association); end
  def either_joins(initial_association, fallback_association); end
  def either_order(direction, **associations_and_columns); end
  def either_orders(direction, **associations_and_columns); end

  private

  def map_columns_to_tables(associations_and_columns); end
  def sort_order_sql(dir); end
  def xor_field_options(options); end
  def xor_field_options_for_associations(associations); end
  def xor_field_sql(options); end
end

ActiveRecordExtended::QueryMethods::Either::XOR_FIELD_KEYS = T.let(T.unsafe(nil), Array)
ActiveRecordExtended::QueryMethods::Either::XOR_FIELD_SQL = T.let(T.unsafe(nil), String)

module ActiveRecordExtended::QueryMethods::Inet
  # Finds matching inet column records that fall within a given submasked IP range
  #
  # Column(inet) << "127.0.0.1/24"
  #
  # User.where.inet_contained_within(ip: "127.0.0.1/16")
  #  #=> "SELECT \"users\".* FROM \"users\" WHERE \"users\".\"ip\" << '127.0.0.1/16'"
  #
  # User.where.inet_contained_within(ip: IPAddr.new("192.168.2.0/24"))
  #  #=> "SELECT \"users\".* FROM \"users\" WHERE \"users\".\"ip\" << '192.168.2.0/24'"
  def inet_contained_within(opts, *rest); end

  # Finds matching inet column records that fall within a given submasked IP range and also finds records that also
  # contain a submasking field that fall within range too.
  #
  # Column(inet) <<= "127.0.0.1/24"
  #
  # User.where.inet_contained_within_or_equals(ip: "127.0.0.1/16")
  #  #=> "SELECT \"users\".* FROM \"users\" WHERE \"users\".\"ip\" <<= '127.0.0.44/32'"
  #
  # User.where.inet_contained_within_or_equals(ip: IPAddr.new("192.168.2.0/24"))
  #  #=> "SELECT \"users\".* FROM \"users\" WHERE \"users\".\"ip\" <<= '192.168.2.0/24'"
  def inet_contained_within_or_equals(opts, *rest); end

  # Strictly finds records that contain a submask and the supplied IP address falls within its range.
  #
  # Column(inet) >>= "127.0.0.1"
  #
  # User.where.inet_contained_within_or_equals(ip: "127.0.255.255")
  #  #=> "SELECT \"users\".* FROM \"users\" WHERE \"users\".\"ip\" >> '127.0.255.255'"
  #
  # User.where.inet_contained_within_or_equals(ip: IPAddr.new("127.0.0.255"))
  #  #=> "SELECT \"users\".* FROM \"users\" WHERE \"users\".\"ip\" >> '127.0.0.255/32'"
  def inet_contains(opts, *rest); end

  # Finds records that contain a submask and the supplied IP address falls within its range.
  #
  # Column(inet) >>= "127.0.0.1/24"
  #
  # User.where.inet_contained_within_or_equals(ip: "127.0.255.255")
  #  #=> "SELECT \"users\".* FROM \"users\" WHERE \"users\".\"ip\" >>= '127.0.255.255'"
  #
  # User.where.inet_contained_within_or_equals(ip: IPAddr.new("127.0.0.255"))
  #  #=> "SELECT \"users\".* FROM \"users\" WHERE \"users\".\"ip\" >>= '127.0.0.255/32'"
  def inet_contains_or_equals(opts, *rest); end

  # This method is a combination of `inet_contains` and `inet_contained_within`
  #
  # Finds records that are contained within a given submask. And will also find records where their submask is also
  # contains a given IP or IP submask.
  #
  # Column(inet) && "127.0.0.1/28"
  #
  # User.where.inet_contains_or_is_contained_by(ip: "127.0.255.255/28")
  #  #=> "SELECT \"users\".* FROM \"users\" WHERE \"users\".\"ip\" && '127.0.255.255/28'"
  #
  # User.where.inet_contains_or_is_contained_by(ip: IPAddr.new("127.0.0.255"))
  #  #=> "SELECT \"users\".* FROM \"users\" WHERE \"users\".\"ip\" && '127.0.0.255/32'"
  def inet_contains_or_is_contained_within(opts, *rest); end
end

module ActiveRecordExtended::QueryMethods::Json
  # Appends a hash literal to the calling relations response
  #
  # Arguments: Requires an Array or Hash set of values
  #
  # Options:
  #
  #  - as: [Symbol or String] (default="results"): What the column will be aliased to
  #
  # Example:
  #  - Supplying inputs as a Hash
  #      query = User.json_build_literal(number: 1, last_name: "json", pi: 3.14)
  #      query.take.results #=> { "number" => 1, "last_name" => "json", "pi" => 3.14 }
  #
  #  - Supplying inputs as an Array
  #
  #      query = User.json_build_literal(:number, 1, :last_name, "json", :pi, 3.14)
  #      query.take.results #=> { "number" => 1, "last_name" => "json", "pi" => 3.14 }
  def json_build_literal(*args); end

  # Creates a json response object that will convert all subquery results into a json compatible response
  #
  # Arguments:
  #   key: [Symbol or String]: What should this response return as
  #   from: [String, Arel, or ActiveRecord::Relation] : A subquery that can be nested into the top-level from clause
  #
  # Options:
  #   - as: [Symbol or String] (default="results"): What the column will be aliased to
  #
  #
  #   - value: [Symbol or String] (defaults=[key]): How the response should handel the json value return
  #
  # Example:
  #
  #   - Generic example:
  #
  #   subquery = Group.select(:name, :category_id).where("user_id = users.id")
  #   User.select(:name, email).select_row_to_json(subquery, as: :users_groups, cast_with: :array)
  #     #=> [<#User name:.., email:.., users_groups: [{ name: .., category_id: .. }, ..]]
  #
  #  - Setting a custom value:
  #
  #   Before:
  #       subquery = User.select(:name).where(id: 100..110).group(:name)
  #       User.build_json_object(:gang_members, subquery).take.results["gang_members"] #=> nil
  #
  #   After:
  #    User.build_json_object(:gang_members, subquery, value: "COALESCE(array_agg(\"gang_members\"), 'BANG!')")
  #        .take
  #        .results["gang_members"] #=> "BANG!"
  def json_build_object(key, from, **options); end

  def jsonb_build_literal(*args); end
  def jsonb_build_object(key, from, **options); end

  # Appends a select statement that contains a subquery that is converted to a json response
  #
  # Arguments:
  #   - from: [String, Arel, or ActiveRecord::Relation] A subquery that can be nested into a ROW_TO_JSON clause
  #
  # Options:
  #   - as: [Symbol or String] (default="results"): What the column will be aliased to
  #
  #   - key: [Symbol or String] (default=[random letter]) What the row clause will be set as.
  #         - This is useful if you would like to add additional mid-level clauses (see mid-level scope example)
  #
  #   - cast_with [Symbol or Array of symbols]: Actions to transform your query
  #     * :to_jsonb
  #     * :array
  #     * :array_agg (including just :array with this option will favor :array_agg)
  #     * :distinct  (auto applies :array_agg & :to_jsonb)
  #
  #   - order_by [Symbol or hash]: Applies an ordering operation (similar to ActiveRecord #order)
  #     - NOTE: this option will be ignored if you need to order a DISTINCT Aggregated Array,
  #             since postgres will thrown an error.
  #
  #
  #
  # Examples:
  #   subquery = Group.select(:name, :category_id).where("user_id = users.id")
  #   User.select(:name, email).select_row_to_json(subquery, as: :users_groups, cast_with: :array)
  #     #=> [<#User name:.., email:.., users_groups: [{ name: .., category_id: .. }, ..]]
  #
  #  - Adding mid-level scopes:
  #
  #   subquery = Group.select(:name, :category_id)
  #   User.select_row_to_json(subquery, key: :group, cast_with: :array) do |scope|
  #     scope.where(group: { name: "Nerd Core" })
  #   end
  #    #=>  ```sql
  #       SELECT ARRAY(
  #             SELECT ROW_TO_JSON("group")
  #             FROM(SELECT name, category_id FROM groups) AS group
  #             WHERE group.name = 'Nerd Core'
  #       )
  #    ```
  #
  #
  # - Array of JSONB objects
  #
  #   subquery = Group.select(:name, :category_id)
  #   User.select_row_to_json(subquery, key: :group, cast_with: [:array, :to_jsonb]) do |scope|
  #     scope.where(group: { name: "Nerd Core" })
  #   end
  #   #=>  ```sql
  #       SELECT ARRAY(
  #             SELECT TO_JSONB(ROW_TO_JSON("group"))
  #             FROM(SELECT name, category_id FROM groups) AS group
  #             WHERE group.name = 'Nerd Core'
  #       )
  #   ```
  #
  # - Distinct Aggregated Array
  #
  #   subquery = Group.select(:name, :category_id)
  #   User.select_row_to_json(subquery, key: :group, cast_with: [:array_agg, :distinct]) do |scope|
  #     scope.where(group: { name: "Nerd Core" })
  #   end
  #   #=>  ```sql
  #      SELECT ARRAY_AGG(DISTINCT (
  #            SELECT TO_JSONB(ROW_TO_JSON("group"))
  #            FROM(SELECT name, category_id FROM groups) AS group
  #            WHERE group.name = 'Nerd Core'
  #      ))
  #   ```
  #
  # - Ordering a Non-aggregated Array
  #
  #  subquery = Group.select(:name, :category_id)
  #  User.select_row_to_json(subquery, key: :group, cast_with: :array, order_by: { group: { name: :desc } })
  #  #=>  ```sql
  #     SELECT ARRAY(
  #           SELECT ROW_TO_JSON("group")
  #           FROM(SELECT name, category_id FROM groups) AS group
  #           ORDER BY group.name DESC
  #     )
  #  ```
  #
  # - Ordering an Aggregated Array
  #
  #  Subquery = Group.select(:name, :category_id)
  #  User
  #   .joins(:people_groups)
  #  .select_row_to_json(
  #     subquery,
  #     key: :group,
  #     cast_with: :array_agg,
  #     order_by: { people_groups: :category_id }
  #   )
  #   #=>  ```sql
  #     SELECT ARRAY_AGG((
  #           SELECT ROW_TO_JSON("group")
  #           FROM(SELECT name, category_id FROM groups) AS group
  #           ORDER BY group.name DESC
  #     ) ORDER BY people_groups.category_id ASC)
  #   ```
  #
  # @raise [ArgumentError]
  def select_row_to_json(from = T.unsafe(nil), **options, &block); end
end

ActiveRecordExtended::QueryMethods::Json::JSON_QUERY_METHODS = T.let(T.unsafe(nil), Array)

class ActiveRecordExtended::QueryMethods::Json::JsonChain
  include ::ActiveRecordExtended::Utilities::Support
  include ::ActiveRecordExtended::Utilities::OrderBy

  # @return [JsonChain] a new instance of JsonChain
  def initialize(scope); end

  def json_build_literal!(*args); end
  def json_build_object!(*args); end
  def jsonb_build_literal!(*args); end
  def jsonb_build_object!(*args); end
  def row_to_json!(**args, &block); end

  private

  def build_json_literal(arel_klass, values:, col_alias: T.unsafe(nil)); end
  def build_json_object(arel_klass, from:, key: T.unsafe(nil), value: T.unsafe(nil), col_alias: T.unsafe(nil)); end
  def build_row_to_json(from:, **options, &block); end
  def casting_options(cast_with); end
  def json_object_options(args, except: T.unsafe(nil), only: T.unsafe(nil)); end
  def wrap_row_to_json(dummy_table, options); end
end

ActiveRecordExtended::QueryMethods::Json::JsonChain::ARRAY_OPTIONS = T.let(T.unsafe(nil), Array)
ActiveRecordExtended::QueryMethods::Json::JsonChain::DEFAULT_ALIAS = T.let(T.unsafe(nil), String)
ActiveRecordExtended::QueryMethods::Json::JsonChain::TO_JSONB_OPTIONS = T.let(T.unsafe(nil), Set)

module ActiveRecordExtended::QueryMethods::Select
  def _foster_select!(*args); end

  # @raise [ArgumentError]
  def foster_select(*args); end
end

class ActiveRecordExtended::QueryMethods::Select::SelectHelper
  include ::ActiveRecordExtended::Utilities::Support
  include ::ActiveRecordExtended::Utilities::OrderBy

  # @return [SelectHelper] a new instance of SelectHelper
  def initialize(scope); end

  def build_foster_select(*args); end

  private

  # Turn a hash chain into a query statement:
  # Example: hash_to_dot_notation(table_name: :col_name) #=> "table_name.col_name"
  def hash_to_dot_notation(column); end

  # Assumes that the first element in the array is the source/target column.
  # Example
  # process_array_options!([:col_name], :my_alias_name)
  #    #=> SELECT ([:col_name:]) AS "my_alias_name", ...
  def process_array!(array_of_options, alias_name); end

  # Processes options that come in as Hash elements
  # Examples:
  # process_hash_options!({ memberships: :price, cast_with: :agg_array_distinct }, :past_purchases)
  #  #=> SELECT (ARRAY_AGG(DISTINCT members.price)) AS past_purchases, ...
  def process_hash!(hash_of_options, alias_name); end

  # Add's select statement values to the current relation, select statement lists
  def select!(query, alias_name = T.unsafe(nil), **options); end

  # Wraps the query with the requested query method
  # Example:
  #   to_casted_query("memberships.cost", :total_revenue, :sum)
  #    #=> SELECT (SUM(memberships.cost)) AS total_revenue
  def to_casted_query(query, alias_name, **options); end
end

ActiveRecordExtended::QueryMethods::Select::SelectHelper::AGGREGATE_ONE_LINERS = T.let(T.unsafe(nil), Regexp)

module ActiveRecordExtended::QueryMethods::Unionize
  def order_union(opts = T.unsafe(nil), *args); end
  def reorder_union(opts = T.unsafe(nil), *args); end
  def to_nice_union_sql(color = T.unsafe(nil)); end

  # Will construct *Just* the union SQL statement that was been built thus far
  def to_union_sql; end

  def union(opts = T.unsafe(nil), *args); end
  def union!(opts = T.unsafe(nil), *args, chain_method: T.unsafe(nil)); end
  def union_all(opts = T.unsafe(nil), *args); end
  def union_as(opts = T.unsafe(nil), *args); end
  def union_except(opts = T.unsafe(nil), *args); end
  def union_intersect(opts = T.unsafe(nil), *args); end
  def union_operations; end
  def union_operations=(value); end
  def union_operations?; end
  def union_ordering_values; end
  def union_ordering_values=(value); end
  def union_ordering_values?; end
  def union_values; end
  def union_values=(value); end
  def union_values?; end
  def unionize_storage; end
  def unionize_storage!; end
  def unionized_name; end
  def unionized_name=(value); end
  def unionized_name?; end

  protected

  # Apply's the allowed ORDER BY to the end of the final union statement
  #
  # Note: This will only apply at the very end of the union statements. Not nested ones.
  #       (I guess you could double nest a union and apply it, but that would be dumb)
  #
  # Example:
  #   User.union(User.select(:id).where(id: 8))
  #       .union(User.select(:id).where(id: 50))
  #       .union.order(id: :desc)
  #  #=> [<#User id: 50>, <#User id: 8>]
  #
  #   ```sql
  #   SELECT users.*
  #   FROM(
  #       (SELECT users.id FROM users WHERE id = 8)
  #       UNION
  #       (SELECT users.id FROM users WHERE id = 50)
  #       ORDER BY id DESC
  #    ) users;
  #   ```
  def apply_union_ordering(union_nodes); end

  # Builds a set of nested nodes that union each other's results
  #
  # Note: Order of chained unions *DOES* matter
  #
  # Example:
  #
  #   User.union(User.select(:id).where(id: 8))
  #       .union(User.select(:id).where(id: 50))
  #       .union.except(User.select(:id).where(id: 8))
  #
  #   #=> [<#User id: 50]]
  #
  #   ```sql
  #   SELECT users.*
  #   FROM(
  #       (
  #         (SELECT users.id FROM users WHERE id = 8)
  #         UNION
  #         (SELECT users.id FROM users WHERE id = 50)
  #       )
  #       EXCEPT
  #       (SELECT users.id FROM users WHERE id = 8)
  #    ) users;
  #   ```
  def build_union_nodes!(raise_error = T.unsafe(nil)); end

  def build_unions(arel = T.unsafe(nil)); end

  private

  def resolve_relation_node(relation_node); end
  def unionize_error_or_warn!(raise_error = T.unsafe(nil)); end
end

ActiveRecordExtended::QueryMethods::Unionize::UNIONIZE_METHODS = T.let(T.unsafe(nil), Array)
ActiveRecordExtended::QueryMethods::Unionize::UNION_RELATION_METHODS = T.let(T.unsafe(nil), Array)

class ActiveRecordExtended::QueryMethods::Unionize::UnionChain
  include ::ActiveRecordExtended::Utilities::Support
  include ::ActiveRecordExtended::Utilities::OrderBy

  # @return [UnionChain] a new instance of UnionChain
  def initialize(scope); end

  def all(*args); end
  def as(from_clause_name); end
  def except(*args); end
  def intersect(*args); end
  def order(*ordering_args); end
  def order_union(*ordering_args); end
  def reorder(*ordering_args); end
  def reorder_union(*ordering_args); end
  def union(*args); end
  def union_all(*args); end
  def union_as(from_clause_name); end
  def union_except(*args); end
  def union_intersect(*args); end

  protected

  def append_union_order!(union_type, args); end
  def calculate_union_operation!(union_type, scope_count); end
end

module ActiveRecordExtended::QueryMethods::Window
  def build_windows(arel); end
  def define_window(name); end
  def define_window!(name); end
  def select_window(window_function, *args, over:, as: T.unsafe(nil)); end
  def select_window!(window_function, *args, over:, as: T.unsafe(nil)); end
  def window_values; end
  def window_values!; end
  def window_values=(*values); end

  # @return [Boolean]
  def window_values?; end
end

class ActiveRecordExtended::QueryMethods::Window::DefineWindowChain
  include ::ActiveRecordExtended::Utilities::Support
  include ::ActiveRecordExtended::Utilities::OrderBy

  # @return [DefineWindowChain] a new instance of DefineWindowChain
  def initialize(scope, window_name); end

  def partition_by(*partitions, order_by: T.unsafe(nil)); end
end

class ActiveRecordExtended::QueryMethods::Window::WindowSelectBuilder
  include ::ActiveRecordExtended::Utilities::Support

  # @return [WindowSelectBuilder] a new instance of WindowSelectBuilder
  def initialize(window_function, args, window_name); end

  def build_select(alias_name = T.unsafe(nil)); end
end

module ActiveRecordExtended::QueryMethods::WithCTE
  def build_with(arel); end

  # @return [WithCTE]
  def cte; end

  # @param cte [WithCTE]
  # @raise [TypeError]
  def cte=(cte); end

  # @param value [Boolean]
  # @raise [ImmutableRelation]
  def recursive_value=(value); end

  # @return [Boolean]
  def recursive_value?; end

  # @param opts [Hash, WithCTE]
  def with(opts = T.unsafe(nil), *rest); end

  # @param opts [Hash, WithCTE]
  def with!(opts = T.unsafe(nil), *_rest); end

  # @param values [Hash, WithCTE]
  def with_values=(values); end

  # @return [Boolean]
  def with_values?; end
end

class ActiveRecordExtended::QueryMethods::WithCTE::WithCTE
  include ::ActiveRecordExtended::Utilities::Support
  include ::Enumerable
  extend ::Forwardable

  # @param scope [ActiveRecord::Relation]
  # @return [WithCTE] a new instance of WithCTE
  def initialize(scope); end

  def blank?(*args, **_arg1, &block); end

  # @return [Enumerable] Returns the order for which CTE's were imported as.
  def each; end

  # @return [Enumerable] Returns the order for which CTE's were imported as.
  def each_pair; end

  def empty?(*args, **_arg1, &block); end

  # @param value [Hash, WithCTE]
  def pipe_cte_with!(value); end

  def present?(*args, **_arg1, &block); end
  def reset!; end

  # Returns the value of attribute with_keys.
  def with_keys; end

  # Returns the value of attribute with_values.
  def with_values; end

  # @param value [Hash, WithCTE]
  def with_values=(value); end
end

class ActiveRecordExtended::QueryMethods::WithCTE::WithChain
  # @param scope [ActiveRecord::Relation]
  # @return [WithChain] a new instance of WithChain
  def initialize(scope); end

  # @param args [Hash, WithCTE]
  def recursive(args); end
end

module ActiveRecordExtended::RelationPatch; end

module ActiveRecordExtended::RelationPatch::ArelBuildPatch
  def build_arel(*aliases); end
end

module ActiveRecordExtended::RelationPatch::Merger
  def merge; end
  def merge_ctes!; end
  def normal_values; end
end

module ActiveRecordExtended::RelationPatch::QueryDelegation
  def define_window(*_arg0, **_arg1, &_arg2); end
  def foster_select(*_arg0, **_arg1, &_arg2); end
  def json_build_literal(*_arg0, **_arg1, &_arg2); end
  def json_build_object(*_arg0, **_arg1, &_arg2); end
  def jsonb_build_literal(*_arg0, **_arg1, &_arg2); end
  def jsonb_build_object(*_arg0, **_arg1, &_arg2); end
  def select_row_to_json(*_arg0, **_arg1, &_arg2); end
  def select_window(*_arg0, **_arg1, &_arg2); end
  def union(*_arg0, **_arg1, &_arg2); end
  def union_all(*_arg0, **_arg1, &_arg2); end
  def union_except(*_arg0, **_arg1, &_arg2); end
  def union_intersect(*_arg0, **_arg1, &_arg2); end
  def with(*_arg0, **_arg1, &_arg2); end
end

module ActiveRecordExtended::Utilities; end

module ActiveRecordExtended::Utilities::OrderBy
  def inline_order_by(arel_node, ordering_args); end

  # Processes "ORDER BY" expressions for supported aggregate functions
  def order_by_expression(order_by); end

  def process_ordering_arguments!(ordering_args); end
  def scope_preprocess_order_args(ordering_args); end

  # Turns a hash into a dot notation path.
  #
  # Example:
  # - Using pre-set directions:
  #   [{ products: { position: :asc, id: :desc } }]
  #     #=> [{ "products.position" => :asc, "products.id" => :desc }]
  #
  # - Using fallback directions:
  #   [{products: :position}]
  #     #=> [{"products.position" => :asc}]
  def to_ordered_table_path(args); end
end

module ActiveRecordExtended::Utilities::Support
  # Ensures the given value is properly double quoted.
  # This also ensures we don't have conflicts with reversed keywords.
  #
  # IE: `user` is a reserved keyword in PG. But `"user"` is allowed and works the same
  #     when used as an column/tbl alias.
  def double_quote(value); end

  def flatten_safely(values, &block); end

  # We need to ensure we can flatten nested ActiveRecord::Relations
  # that might have been nested due to the (splat)*args parameters
  #
  # Note: calling `Array.flatten[!]/1` will actually remove all AR relations from the array.
  def flatten_to_sql(*values); end

  # Will attempt to digest and resolve the from clause
  #
  # If the from clause is a String, it will check to see if a table reference key has been assigned.
  #   - If one cannot be detected, one will be appended.
  #   - Rails does not allow assigning table references using the `.from/2` method, when its a string / sym type.
  #
  # If the from clause is an AR relation; it will duplicate the object.
  #   - Ensures any memorizers are reset (ex: `.to_sql` sets a memorizer on the instance)
  #   - Key's can be assigned using the `.from/2` method.
  def from_clause_constructor(from, reference_key); end

  def generate_grouping(expr); end
  def generate_named_function(function_name, *args); end
  def group_when_needed(arel_or_rel_query); end
  def key_generator; end

  # Ensures the key is properly single quoted and treated as a actual PG key reference.
  def literal_key(key); end

  # @return [Boolean]
  def needs_to_be_grouped?(query); end

  # Applies aliases to the given query
  # Ex: `SELECT * FROM users` => `(SELECT * FROM users) AS "members"`
  def nested_alias_escape(query, alias_name); end

  # Will carry defined CTE tables from the nested sub-query and gradually pushes it up to the parents query stack
  # I.E: It pushes `WITH [:cte_name:] AS(...), ..` to the top of the query structure tree
  #
  # SPECIAL GOTCHA NOTE: (if duplicate keys are found) This will favor the parents query `with's` over nested ones!
  def pipe_cte_with!(subquery); end

  # Converts a potential subquery into a compatible Arel SQL node.
  #
  # Note:
  # We convert relations to SQL to maintain compatibility with Rails 5.1.
  # Only Rails 5.2+ maintains bound attributes in Arel, so its better to be safe then sorry.
  # When we drop support for Rails 5.1, we then can then drop the '.to_sql' conversation
  def to_arel_sql(value); end

  # We need to ensure we can flatten nested ActiveRecord::Relations
  # that might have been nested due to the (splat)*args parameters
  #
  # Note: calling `Array.flatten[!]/1` will actually remove all AR relations from the array.
  def to_sql_array(*values); end

  # Wraps query into an aggregated array
  # EX: `(ARRAY_AGG((SELECT * FROM users)) AS "members"`
  #     `(ARRAY_AGG(DISTINCT (SELECT * FROM users)) AS "members"`
  #     `SELECT ARRAY_AGG((id)) AS "ids" FROM users`
  #     `SELECT ARRAY_AGG(DISTINCT (id)) AS "ids" FROM users`
  def wrap_with_agg_array(arel_or_rel_query, alias_name, order_by: T.unsafe(nil), distinct: T.unsafe(nil)); end

  # Wraps subquery into an Aliased ARRAY
  # Ex: `SELECT * FROM users` => (ARRAY(SELECT * FROM users)) AS "members"
  def wrap_with_array(arel_or_rel_query, alias_name, order_by: T.unsafe(nil)); end
end

ActiveRecordExtended::Utilities::Support::A_TO_Z_KEYS = T.let(T.unsafe(nil), Array)
ActiveRecordExtended::VERSION = T.let(T.unsafe(nil), String)
module ActiveRecordExtended::Visitors; end

module ActiveRecordExtended::Visitors::PostgreSQLDecorator
  private

  # @return [Boolean]
  def matchable_column?(col, object); end

  def visit_Arel_Nodes_AggregateFunctionName(object, collector); end
  def visit_Arel_Nodes_Array(object, collector); end
  def visit_Arel_Nodes_ArrayAgg(object, collector); end
  def visit_Arel_Nodes_ContainedInArray(object, collector); end
  def visit_Arel_Nodes_ContainedInHStore(object, collector); end
  def visit_Arel_Nodes_Contains(object, collector); end
  def visit_Arel_Nodes_ContainsArray(object, collector); end
  def visit_Arel_Nodes_ContainsHStore(object, collector); end
  def visit_Arel_Nodes_Inet_ContainedWithin(object, collector); end
  def visit_Arel_Nodes_Inet_ContainedWithinEquals(object, collector); end
  def visit_Arel_Nodes_Inet_Contains(object, collector); end
  def visit_Arel_Nodes_Inet_ContainsEquals(object, collector); end
  def visit_Arel_Nodes_Inet_ContainsOrContainedWithin(object, collector); end
  def visit_Arel_Nodes_JsonBuildObject(object, collector); end
  def visit_Arel_Nodes_JsonbBuildObject(object, collector); end
  def visit_Arel_Nodes_Overlaps(object, collector); end
  def visit_Arel_Nodes_RowToJson(object, collector); end
  def visit_Arel_Nodes_ToJson(object, collector); end
  def visit_Arel_Nodes_ToJsonb(object, collector); end
end

module ActiveRecordExtended::WhereChain
  # Finds Records that contain a single matchable array element
  # User.where.all(tags: 3)
  #   # SELECT user.* FROM user WHERE 3 = ALL(user.tags)
  def all(opts, *rest); end

  # Finds Records that contain an element in an array column
  # User.where.any(tags: 3)
  #   # SELECT user.* FROM user WHERE 3 = ANY(user.tags)
  def any(opts, *rest); end

  # Finds Records that contains a nested set elements
  #
  # Array Column Type:
  #   User.where.contains(tags: [1, 3])
  #   # SELECT user.* FROM user WHERE user.tags @> {1,3}
  #
  # HStore Column Type:
  #   User.where.contains(data: { nickname: 'chainer' })
  #   # SELECT user.* FROM user WHERE user.data @> 'nickname' => 'chainer'
  #
  # JSONB Column Type:
  #   User.where.contains(data: { nickname: 'chainer' })
  #   # SELECT user.* FROM user WHERE user.data @> {'nickname': 'chainer'}
  #
  # This can also be used along side joined tables
  #
  # JSONB Column Type Example:
  #   Tag.joins(:user).where.contains(user: { data: { nickname: 'chainer' } })
  #   # SELECT tags.* FROM tags INNER JOIN user on user.id = tags.user_id WHERE user.data @> { nickname: 'chainer' }
  def contains(opts, *rest); end

  # Finds Records that have an array column that contain any a set of values
  # User.where.overlap(tags: [1,2])
  #   # SELECT * FROM users WHERE tags && {1,2}
  def overlap(opts, *rest); end

  # Finds Records that have an array column that contain any a set of values
  # User.where.overlap(tags: [1,2])
  #   # SELECT * FROM users WHERE tags && {1,2}
  def overlaps(opts, *rest); end

  private

  def assoc_from_related_table(arel); end
  def build_where_clause_for(scope, opts, rest); end
  def column_from_association(arel); end
  def equality_to_function(function_name, opts, rest); end
  def left_column(arel); end

  # @return [Boolean]
  def matchable_column?(col, arel); end

  def substitute_comparisons(opts, rest, arel_node_class, method); end
end

ActiveRecordExtended::WhereChain::AR_VERSION_AT_LEAST_6_1 = T.let(T.unsafe(nil), TrueClass)

module ActiveRecordExtended::WhereClause
  def modified_predicates(&block); end
end

# CTE alias fix for Rails 6.1
module Arel
  class << self
    def arel_node?(value); end
    def fetch_attribute(value, &block); end
    def sql(raw_sql); end
    def star; end
  end
end

Arel::Attribute = Arel::Attributes::Attribute

module Arel::Nodes
  class << self
    def build_quoted(other, attribute = T.unsafe(nil)); end
  end
end

class Arel::Nodes::AggregateFunctionName < ::Arel::Nodes::Node
  include ::Arel::Predications
  include ::Arel::WindowPredications

  # @return [AggregateFunctionName] a new instance of AggregateFunctionName
  def initialize(name, expr, distinct = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(other); end

  # Returns the value of attribute alias.
  def alias; end

  # Sets the attribute alias
  #
  # @param value the value to set the attribute alias to.
  def alias=(_arg0); end

  def as(aliaz); end

  # Returns the value of attribute distinct.
  def distinct; end

  # Sets the attribute distinct
  #
  # @param value the value to set the attribute distinct to.
  def distinct=(_arg0); end

  # @return [Boolean]
  def eql?(other); end

  # Returns the value of attribute expressions.
  def expressions; end

  # Sets the attribute expressions
  #
  # @param value the value to set the attribute expressions to.
  def expressions=(_arg0); end

  def hash; end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  def order_by(expr); end

  # Returns the value of attribute orderings.
  def orderings; end

  # Sets the attribute orderings
  #
  # @param value the value to set the attribute orderings to.
  def orderings=(_arg0); end
end

class Arel::Nodes::Array < ::Arel::Nodes::Function
  def initialize(*args); end
end

class Arel::Nodes::ArrayAgg < ::Arel::Nodes::Function
  def initialize(*args); end
end

class Arel::Nodes::As < ::Arel::Nodes::Binary; end
class Arel::Nodes::Assignment < ::Arel::Nodes::Binary; end
class Arel::Nodes::Avg < ::Arel::Nodes::Function; end
class Arel::Nodes::Bin < ::Arel::Nodes::Unary; end
class Arel::Nodes::ContainedInArray < ::Arel::Nodes::Binary; end
class Arel::Nodes::ContainsArray < ::Arel::Nodes::Binary; end
class Arel::Nodes::ContainsHStore < ::Arel::Nodes::Binary; end
class Arel::Nodes::Cube < ::Arel::Nodes::Unary; end
class Arel::Nodes::DistinctOn < ::Arel::Nodes::Unary; end
class Arel::Nodes::Except < ::Arel::Nodes::Binary; end
class Arel::Nodes::Exists < ::Arel::Nodes::Function; end
class Arel::Nodes::Group < ::Arel::Nodes::Unary; end
class Arel::Nodes::GroupingElement < ::Arel::Nodes::Unary; end
class Arel::Nodes::GroupingSet < ::Arel::Nodes::Unary; end
module Arel::Nodes::Inet; end
class Arel::Nodes::Inet::ContainedWithin < ::Arel::Nodes::Binary; end
class Arel::Nodes::Inet::ContainedWithinEquals < ::Arel::Nodes::Binary; end
class Arel::Nodes::Inet::Contains < ::Arel::Nodes::Binary; end
class Arel::Nodes::Inet::ContainsEquals < ::Arel::Nodes::Binary; end
class Arel::Nodes::Inet::ContainsOrContainedWithin < ::Arel::Nodes::Binary; end
class Arel::Nodes::Intersect < ::Arel::Nodes::Binary; end
class Arel::Nodes::Join < ::Arel::Nodes::Binary; end

class Arel::Nodes::JsonBuildObject < ::Arel::Nodes::Function
  def initialize(*args); end
end

class Arel::Nodes::JsonbBuildObject < ::Arel::Nodes::Function
  def initialize(*args); end
end

class Arel::Nodes::Lateral < ::Arel::Nodes::Unary; end
class Arel::Nodes::Limit < ::Arel::Nodes::Unary; end
class Arel::Nodes::Lock < ::Arel::Nodes::Unary; end
class Arel::Nodes::Max < ::Arel::Nodes::Function; end
class Arel::Nodes::Min < ::Arel::Nodes::Function; end
class Arel::Nodes::Not < ::Arel::Nodes::Unary; end
class Arel::Nodes::Offset < ::Arel::Nodes::Unary; end
class Arel::Nodes::On < ::Arel::Nodes::Unary; end
class Arel::Nodes::OptimizerHints < ::Arel::Nodes::Unary; end
class Arel::Nodes::RollUp < ::Arel::Nodes::Unary; end

class Arel::Nodes::RowToJson < ::Arel::Nodes::Function
  def initialize(*args); end
end

module Arel::Nodes::SqlLiteralDecorator
  def name; end
end

class Arel::Nodes::Sum < ::Arel::Nodes::Function; end

class Arel::Nodes::ToJson < ::Arel::Nodes::Function
  def initialize(*args); end
end

class Arel::Nodes::ToJsonb < ::Arel::Nodes::Function
  def initialize(*args); end
end

class Arel::Nodes::Union < ::Arel::Nodes::Binary; end
class Arel::Nodes::UnionAll < ::Arel::Nodes::Binary; end

module Arel::Predications
  def all(other); end
  def any(other); end
  def between(other); end
  def concat(other); end
  def contained_in_array(other); end
  def contains(other); end
  def does_not_match(other, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end
  def does_not_match_all(others, escape = T.unsafe(nil)); end
  def does_not_match_any(others, escape = T.unsafe(nil)); end
  def does_not_match_regexp(other, case_sensitive = T.unsafe(nil)); end
  def eq(other); end
  def eq_all(others); end
  def eq_any(others); end
  def gt(right); end
  def gt_all(others); end
  def gt_any(others); end
  def gteq(right); end
  def gteq_all(others); end
  def gteq_any(others); end
  def in(other); end
  def in_all(others); end
  def in_any(others); end
  def inet_contained_within(other); end
  def inet_contained_within_or_equals(other); end
  def inet_contains(other); end
  def inet_contains_or_equals(other); end
  def inet_contains_or_is_contained_within(other); end
  def is_distinct_from(other); end
  def is_not_distinct_from(other); end
  def lt(right); end
  def lt_all(others); end
  def lt_any(others); end
  def lteq(right); end
  def lteq_all(others); end
  def lteq_any(others); end
  def matches(other, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end
  def matches_all(others, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end
  def matches_any(others, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end
  def matches_regexp(other, case_sensitive = T.unsafe(nil)); end
  def not_between(other); end
  def not_eq(other); end
  def not_eq_all(others); end
  def not_eq_any(others); end
  def not_in(other); end
  def not_in_all(others); end
  def not_in_any(others); end
  def overlap(other); end
  def overlaps(other); end
  def quoted_array(others); end
  def when(right); end

  private

  def grouping_all(method_id, others, *extras); end
  def grouping_any(method_id, others, *extras); end
  def infinity?(value); end
  def open_ended?(value); end
  def quoted_node(other); end
  def unboundable?(value); end
end

Arel::VERSION = T.let(T.unsafe(nil), String)
