# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `draper` gem.
# Please instead update this file by running `bin/tapioca gem draper`.

module ActiveModel
  extend ::ActiveSupport::Autoload

  class << self
    def eager_load!; end
    def gem_version; end
    def version; end
  end
end

class ActiveModel::Railtie < ::Rails::Railtie; end

module Draper
  extend ::Draper::Configuration

  class << self
    def setup_action_controller(base); end
    def setup_action_mailer(base); end
    def setup_orm(base); end
    def undecorate(object); end
    def undecorate_chain(object); end
  end
end

module Draper::AutomaticDelegation
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Draper::AutomaticDelegation::ClassMethods

  # @private
  # @return [Boolean]
  def delegatable?(method); end

  def method_missing(method, *args, **_arg2, &block); end

  private

  # Checks if the decorator responds to an instance method, or is able to
  # proxy it to the source object.
  #
  # @return [Boolean]
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end
end

module Draper::AutomaticDelegation::ClassMethods
  # Avoids reloading the model class when ActiveSupport clears autoloaded
  # dependencies in development mode.
  #
  # @private
  def before_remove_const; end

  # @private
  # @return [Boolean]
  def delegatable?(method); end

  def method_missing(method, *args, **_arg2, &block); end

  private

  # Checks if the decorator responds to a class method, or is able to proxy
  # it to the source class.
  #
  # @return [Boolean]
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end
end

class Draper::CollectionDecorator
  include ::Enumerable
  include ::Draper::ViewHelpers
  include ::Draper::QueryMethods
  extend ::Draper::ViewHelpers::ClassMethods
  extend ::Draper::Delegation

  # @option options
  # @option options
  # @param object [Enumerable] collection to decorate.
  # @param options [Hash] a customizable set of options
  # @return [CollectionDecorator] a new instance of CollectionDecorator
  def initialize(object, options = T.unsafe(nil)); end

  def &(*_arg0, **_arg1, &_arg2); end
  def *(*_arg0, **_arg1, &_arg2); end
  def +(*_arg0, **_arg1, &_arg2); end
  def -(*_arg0, **_arg1, &_arg2); end
  def <<(*_arg0, **_arg1, &_arg2); end
  def ==(arg); end
  def [](*_arg0, **_arg1, &_arg2); end
  def []=(*_arg0, **_arg1, &_arg2); end
  def all?(*_arg0, **_arg1, &_arg2); end
  def any?(*_arg0, **_arg1, &_arg2); end
  def append(*_arg0, **_arg1, &_arg2); end
  def as_json(*_arg0, **_arg1, &_arg2); end
  def assoc(*_arg0, **_arg1, &_arg2); end
  def at(*_arg0, **_arg1, &_arg2); end
  def bsearch(*_arg0, **_arg1, &_arg2); end
  def bsearch_index(*_arg0, **_arg1, &_arg2); end
  def chain(*_arg0, **_arg1, &_arg2); end
  def chunk(*_arg0, **_arg1, &_arg2); end
  def chunk_while(*_arg0, **_arg1, &_arg2); end
  def clear(*_arg0, **_arg1, &_arg2); end
  def collect(*_arg0, **_arg1, &_arg2); end
  def collect!(*_arg0, **_arg1, &_arg2); end
  def collect_concat(*_arg0, **_arg1, &_arg2); end
  def combination(*_arg0, **_arg1, &_arg2); end
  def compact(*_arg0, **_arg1, &_arg2); end
  def compact!(*_arg0, **_arg1, &_arg2); end
  def compact_blank(*_arg0, **_arg1, &_arg2); end
  def compact_blank!(*_arg0, **_arg1, &_arg2); end
  def concat(*_arg0, **_arg1, &_arg2); end

  # @return [Hash] extra data to be used in user-defined methods, and passed
  #   to each item's decorator.
  def context; end

  # @return [Hash] extra data to be used in user-defined methods, and passed
  #   to each item's decorator.
  def context=(value); end

  def count(*_arg0, **_arg1, &_arg2); end
  def cycle(*_arg0, **_arg1, &_arg2); end
  def deconstruct(*_arg0, **_arg1, &_arg2); end

  # @return [true]
  def decorated?; end

  # @return [Array] the decorated items.
  def decorated_collection; end

  def decorated_with?(_arg0); end

  # @return [Class] the decorator class used to decorate each item, as set by
  #   {#initialize}.
  def decorator_class; end

  def delete(*_arg0, **_arg1, &_arg2); end
  def delete_at(*_arg0, **_arg1, &_arg2); end
  def delete_if(*_arg0, **_arg1, &_arg2); end
  def detect(*_arg0, **_arg1, &_arg2); end
  def difference(*_arg0, **_arg1, &_arg2); end
  def dig(*_arg0, **_arg1, &_arg2); end
  def drop(*_arg0, **_arg1, &_arg2); end
  def drop_while(*_arg0, **_arg1, &_arg2); end
  def each(*_arg0, **_arg1, &_arg2); end
  def each_cons(*_arg0, **_arg1, &_arg2); end
  def each_entry(*_arg0, **_arg1, &_arg2); end
  def each_index(*_arg0, **_arg1, &_arg2); end
  def each_slice(*_arg0, **_arg1, &_arg2); end
  def each_with_index(*_arg0, **_arg1, &_arg2); end
  def each_with_object(*_arg0, **_arg1, &_arg2); end
  def empty?(*_arg0, **_arg1, &_arg2); end
  def entries(*_arg0, **_arg1, &_arg2); end
  def exclude?(*_arg0, **_arg1, &_arg2); end
  def excluding(*_arg0, **_arg1, &_arg2); end
  def extract!(*_arg0, **_arg1, &_arg2); end
  def extract_options!(*_arg0, **_arg1, &_arg2); end
  def fetch(*_arg0, **_arg1, &_arg2); end
  def fifth(*_arg0, **_arg1, &_arg2); end
  def fill(*_arg0, **_arg1, &_arg2); end
  def filter(*_arg0, **_arg1, &_arg2); end
  def filter!(*_arg0, **_arg1, &_arg2); end
  def filter_map(*_arg0, **_arg1, &_arg2); end
  def find(*_arg0, **_arg1, &_arg2); end
  def find_all(*_arg0, **_arg1, &_arg2); end
  def find_index(*_arg0, **_arg1, &_arg2); end
  def first(*_arg0, **_arg1, &_arg2); end
  def flat_map(*_arg0, **_arg1, &_arg2); end
  def flatten(*_arg0, **_arg1, &_arg2); end
  def flatten!(*_arg0, **_arg1, &_arg2); end
  def forty_two(*_arg0, **_arg1, &_arg2); end
  def fourth(*_arg0, **_arg1, &_arg2); end
  def from(*_arg0, **_arg1, &_arg2); end
  def grep(*_arg0, **_arg1, &_arg2); end
  def grep_v(*_arg0, **_arg1, &_arg2); end
  def group_by(*_arg0, **_arg1, &_arg2); end
  def in_groups(*_arg0, **_arg1, &_arg2); end
  def in_groups_of(*_arg0, **_arg1, &_arg2); end
  def in_order_of(*_arg0, **_arg1, &_arg2); end
  def include?(*_arg0, **_arg1, &_arg2); end
  def including(*_arg0, **_arg1, &_arg2); end
  def index(*_arg0, **_arg1, &_arg2); end
  def index_by(*_arg0, **_arg1, &_arg2); end
  def index_with(*_arg0, **_arg1, &_arg2); end
  def inject(*_arg0, **_arg1, &_arg2); end
  def inquiry(*_arg0, **_arg1, &_arg2); end
  def insert(*_arg0, **_arg1, &_arg2); end
  def intersect?(*_arg0, **_arg1, &_arg2); end
  def intersection(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  def is_a?(klass); end

  def join(*_arg0, **_arg1, &_arg2); end
  def keep_if(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  def kind_of?(klass); end

  def last(*_arg0, **_arg1, &_arg2); end
  def lazy(*_arg0, **_arg1, &_arg2); end
  def length(*_arg0, **_arg1, &_arg2); end
  def many?(*_arg0, **_arg1, &_arg2); end
  def map(*_arg0, **_arg1, &_arg2); end
  def map!(*_arg0, **_arg1, &_arg2); end
  def max(*_arg0, **_arg1, &_arg2); end
  def max_by(*_arg0, **_arg1, &_arg2); end
  def maximum(*_arg0, **_arg1, &_arg2); end
  def member?(*_arg0, **_arg1, &_arg2); end
  def min(*_arg0, **_arg1, &_arg2); end
  def min_by(*_arg0, **_arg1, &_arg2); end
  def minimum(*_arg0, **_arg1, &_arg2); end
  def minmax(*_arg0, **_arg1, &_arg2); end
  def minmax_by(*_arg0, **_arg1, &_arg2); end
  def none?(*_arg0, **_arg1, &_arg2); end

  # @return the collection being decorated.
  def object; end

  def one?(*_arg0, **_arg1, &_arg2); end
  def pack(*_arg0, **_arg1, &_arg2); end
  def partition(*_arg0, **_arg1, &_arg2); end
  def permutation(*_arg0, **_arg1, &_arg2); end
  def pick(*_arg0, **_arg1, &_arg2); end
  def place(*_arg0, **_arg1, &_arg2); end
  def pluck(*_arg0, **_arg1, &_arg2); end
  def pop(*_arg0, **_arg1, &_arg2); end
  def prepend(*_arg0, **_arg1, &_arg2); end
  def product(*_arg0, **_arg1, &_arg2); end
  def push(*_arg0, **_arg1, &_arg2); end
  def rassoc(*_arg0, **_arg1, &_arg2); end
  def reduce(*_arg0, **_arg1, &_arg2); end
  def reject(*_arg0, **_arg1, &_arg2); end
  def reject!(*_arg0, **_arg1, &_arg2); end
  def repeated_combination(*_arg0, **_arg1, &_arg2); end
  def repeated_permutation(*_arg0, **_arg1, &_arg2); end
  def replace(other); end
  def reverse(*_arg0, **_arg1, &_arg2); end
  def reverse!(*_arg0, **_arg1, &_arg2); end
  def reverse_each(*_arg0, **_arg1, &_arg2); end
  def rindex(*_arg0, **_arg1, &_arg2); end
  def rotate(*_arg0, **_arg1, &_arg2); end
  def rotate!(*_arg0, **_arg1, &_arg2); end
  def sample(*_arg0, **_arg1, &_arg2); end
  def second(*_arg0, **_arg1, &_arg2); end
  def second_to_last(*_arg0, **_arg1, &_arg2); end
  def select(*_arg0, **_arg1, &_arg2); end
  def select!(*_arg0, **_arg1, &_arg2); end
  def shelljoin(*_arg0, **_arg1, &_arg2); end
  def shift(*_arg0, **_arg1, &_arg2); end
  def shuffle(*_arg0, **_arg1, &_arg2); end
  def shuffle!(*_arg0, **_arg1, &_arg2); end
  def size(*_arg0, **_arg1, &_arg2); end
  def slice(*_arg0, **_arg1, &_arg2); end
  def slice!(*_arg0, **_arg1, &_arg2); end
  def slice_after(*_arg0, **_arg1, &_arg2); end
  def slice_before(*_arg0, **_arg1, &_arg2); end
  def slice_when(*_arg0, **_arg1, &_arg2); end
  def sole(*_arg0, **_arg1, &_arg2); end
  def sort(*_arg0, **_arg1, &_arg2); end
  def sort!(*_arg0, **_arg1, &_arg2); end
  def sort_by(*_arg0, **_arg1, &_arg2); end
  def sort_by!(*_arg0, **_arg1, &_arg2); end
  def split(*_arg0, **_arg1, &_arg2); end
  def sum(*_arg0, **_arg1, &_arg2); end
  def take(*_arg0, **_arg1, &_arg2); end
  def take_while(*_arg0, **_arg1, &_arg2); end
  def tally(*_arg0, **_arg1, &_arg2); end
  def third(*_arg0, **_arg1, &_arg2); end
  def third_to_last(*_arg0, **_arg1, &_arg2); end
  def to(*_arg0, **_arg1, &_arg2); end
  def to_a(*_arg0, **_arg1, &_arg2); end
  def to_ary(*_arg0, **_arg1, &_arg2); end
  def to_csv(*_arg0, **_arg1, &_arg2); end
  def to_default_s(*_arg0, **_arg1, &_arg2); end
  def to_formatted_s(*_arg0, **_arg1, &_arg2); end
  def to_fs(*_arg0, **_arg1, &_arg2); end
  def to_h(*_arg0, **_arg1, &_arg2); end
  def to_msgpack(*_arg0, **_arg1, &_arg2); end
  def to_s; end
  def to_sentence(*_arg0, **_arg1, &_arg2); end
  def to_set(*_arg0, **_arg1, &_arg2); end
  def to_xml(*_arg0, **_arg1, &_arg2); end
  def transpose(*_arg0, **_arg1, &_arg2); end
  def union(*_arg0, **_arg1, &_arg2); end
  def uniq(*_arg0, **_arg1, &_arg2); end
  def uniq!(*_arg0, **_arg1, &_arg2); end
  def unshift(*_arg0, **_arg1, &_arg2); end
  def values_at(*_arg0, **_arg1, &_arg2); end
  def without(*_arg0, **_arg1, &_arg2); end
  def zip(*_arg0, **_arg1, &_arg2); end
  def |(*_arg0, **_arg1, &_arg2); end

  protected

  # Decorates the given item.
  def decorate_item(item); end

  private

  def item_decorator; end

  class << self
    def decorate(*_arg0); end
  end
end

module Draper::Compatibility; end

# Draper expects your `ApplicationController` to include `ActionView::Rendering`. The
# `ApplicationController` generated by Rails 5 API-only applications (created with
# `rails new --api`) don't by default. However, including `ActionView::Rendering` in
# `ApplicatonController` breaks `render :json` due to `render_to_body` being overridden.
#
# This compatibility patch fixes the issue by restoring the original `render_to_body`
# method after including `ActionView::Rendering`. Ultimately, including `ActionView::Rendering`
# in an ActionController::API may not be supported functionality by Rails (see Rails issue
# for more detail: https://github.com/rails/rails/issues/27211). This hack is meant to be a
# temporary solution until we can find a way to not rely on the controller layer.
module Draper::Compatibility::ApiOnly
  extend ::ActiveSupport::Concern
end

# [Active Job](http://edgeguides.rubyonrails.org/active_job_basics.html) allows you to pass
# ActiveRecord objects to background tasks directly and performs the necessary serialization
# and deserialization. In order to do this, arguments to a background job must implement
# [Global ID](https://github.com/rails/globalid).
#
# This compatibility patch implements Global ID for decorated objects by delegating to the object
# that is decorated. This means you can pass decorated objects to background jobs, but
# the object won't be decorated when it is deserialized. This patch is meant as an intermediate
# fix until we can find a way to deserialize the decorated object correctly.
module Draper::Compatibility::GlobalID
  extend ::ActiveSupport::Concern
  include ::GlobalID::Identification
end

module Draper::Configuration
  # @yield [_self]
  # @yieldparam _self [Draper::Configuration] the object that the method was called on
  def configure; end

  def default_controller; end
  def default_controller=(controller); end
  def default_query_methods_strategy; end
  def default_query_methods_strategy=(strategy); end
end

# Provides shortcuts to decorate objects directly, so you can do
# `@product.decorate` instead of `ProductDecorator.new(@product)`.
#
# This module is included by default into `ActiveRecord::Base` and
# `Mongoid::Document`, but you're using another ORM, or want to decorate
# plain old Ruby objects, you can include it manually.
module Draper::Decoratable
  include ::Draper::Decoratable::Equality
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Draper::Decoratable::ClassMethods

  # The list of decorators that have been applied to the object.
  #
  # @return [Array<Class>] `[]`
  def applied_decorators; end

  # Decorates the object using the inferred {#decorator_class}.
  #
  # @param options [Hash] see {Decorator#initialize}
  def decorate(options = T.unsafe(nil)); end

  # Checks if this object is decorated.
  #
  # @return [false]
  def decorated?; end

  # Checks if a given decorator has been applied to the object.
  #
  # @param decorator_class [Class]
  # @return [false]
  def decorated_with?(decorator_class); end

  # Infers the decorator class to be used by {Decoratable#decorate} (e.g.
  # `Product` maps to `ProductDecorator`).
  #
  # @return [Class] the inferred decorator class.
  def decorator_class; end

  # @return [Boolean]
  def decorator_class?; end
end

module Draper::Decoratable::ClassMethods
  # Compares with possibly-decorated objects.
  #
  # @return [Boolean]
  def ===(other); end

  # Decorates a collection of objects. Used at the end of a scope chain.
  #
  # @example
  #   Product.popular.decorate
  # @param options [Hash] see {Decorator.decorate_collection}.
  def decorate(options = T.unsafe(nil)); end

  # Infers the decorator class to be used by {Decoratable#decorate} (e.g.
  # `Product` maps to `ProductDecorator`).
  #
  # @return [Class] the inferred decorator class.
  def decorator_class(called_on = T.unsafe(nil)); end

  # @return [Boolean]
  def decorator_class?; end
end

module Draper::Decoratable::Equality
  # Compares self with a possibly-decorated object.
  #
  # @return [Boolean]
  def ==(other); end

  class << self
    # Compares an object to a possibly-decorated object.
    #
    # @return [Boolean]
    def test(object, other); end

    # @private
    def test_for_decorator(object, other); end
  end
end

# @private
class Draper::DecoratedAssociation
  # @return [DecoratedAssociation] a new instance of DecoratedAssociation
  def initialize(owner, association, options); end

  def call; end

  private

  # Returns the value of attribute association.
  def association; end

  def decorate; end

  # Returns the value of attribute factory.
  def factory; end

  # Returns the value of attribute owner.
  def owner; end

  # Returns the value of attribute scope.
  def scope; end
end

module Draper::DecoratesAssigned
  # @overload decorates_assigned
  def decorates_assigned(*variables); end
end

class Draper::Decorator
  include ::Draper::ViewHelpers
  include ::Draper::Compatibility::GlobalID
  include ::GlobalID::Identification
  include ::ActiveModel::Serialization
  include ::ActiveModel::Serializers::JSON
  include ::ActiveModel::Serializers::Xml
  extend ::Draper::ViewHelpers::ClassMethods
  extend ::Draper::Delegation
  extend ::ActiveModel::Naming

  # Wraps an object in a new instance of the decorator.
  #
  # Decorators may be applied to other decorators. However, applying a
  # decorator to an instance of itself will create a decorator with the same
  # source as the original, rather than redecorating the other instance.
  #
  # @option options
  # @param object [Object] object to decorate.
  # @param options [Hash] a customizable set of options
  # @return [Decorator] a new instance of Decorator
  def initialize(object, options = T.unsafe(nil)); end

  # Compares the source object with a possibly-decorated object.
  #
  # @return [Boolean]
  def ==(other); end

  # @return [Array<Class>] the list of decorators that have been applied to
  #   the object.
  def applied_decorators; end

  # implemented by the decorator.
  #
  # @return [Hash] the object's attributes, sliced to only include those
  def attributes; end

  def blank?(*_arg0, **_arg1, &_arg2); end

  # @return [Hash] extra data to be used in user-defined methods.
  def context; end

  # @return [Hash] extra data to be used in user-defined methods.
  def context=(_arg0); end

  # Checks if this object is decorated.
  #
  # @return [true]
  def decorated?; end

  # Checks if a given decorator has been applied to the object.
  #
  # @param decorator_class [Class]
  # @return [Boolean]
  def decorated_with?(decorator_class); end

  # Delegates equality to :== as expected
  #
  # @return [Boolean]
  def eql?(other); end

  # Returns a unique hash for a decorated object based on
  # the decorator class and the object being decorated.
  #
  # @return [Fixnum]
  def hash; end

  def include_root_in_json; end
  def include_root_in_json?; end

  # Checks if `self.instance_of?(klass)` or `object.instance_of?(klass)`
  #
  # @param klass [Class]
  # @return [Boolean]
  def instance_of?(klass); end

  # Checks if `self.kind_of?(klass)` or `object.kind_of?(klass)`
  #
  # @param klass [Class]
  # @return [Boolean]
  def is_a?(klass); end

  # Checks if `self.kind_of?(klass)` or `object.kind_of?(klass)`
  #
  # @param klass [Class]
  # @return [Boolean]
  def kind_of?(klass); end

  # @return the object being decorated.
  def model; end

  def model_name(*_arg0, **_arg1, &_arg2); end

  # @return the object being decorated.
  def object; end

  def present?(*_arg0, **_arg1, &_arg2); end
  def to_global_id(*_arg0, **_arg1, &_arg2); end

  # ActiveModel compatibility
  #
  # @private
  def to_model; end

  def to_param(*_arg0, **_arg1, &_arg2); end
  def to_partial_path(*_arg0, **_arg1, &_arg2); end
  def to_s(*_arg0, **_arg1, &_arg2); end
  def to_signed_global_id(*_arg0, **_arg1, &_arg2); end

  private

  def decorated_associations; end
  def handle_multiple_decoration(options); end

  class << self
    def alias_object_to_object_class_name; end

    # @return [Class] the class created by {decorate_collection}.
    def collection_decorator_class; end

    def collection_decorator_name; end
    def decorate(*_arg0); end

    # Decorates a collection of objects. The class of the collection decorator
    # is inferred from the decorator class if possible (e.g. `ProductDecorator`
    # maps to `ProductsDecorator`), but otherwise defaults to
    # {Draper::CollectionDecorator}.
    #
    # @option options
    # @option options
    # @param object [Object] collection to decorate.
    # @param options [Hash] a customizable set of options
    def decorate_collection(object, options = T.unsafe(nil)); end

    # Sets the source class corresponding to the decorator class.
    #
    # @note This is only necessary if you wish to proxy class methods to the
    #   source (including when using {decorates_finders}), and the source class
    #   cannot be inferred from the decorator class (e.g. `ProductDecorator`
    #   maps to `Product`).
    # @param object_class [String, Symbol, Class] source class (or class name) that corresponds to this decorator.
    # @return [void]
    def decorates(object_class); end

    # Automatically decorate an association.
    #
    # @option options
    # @option options
    # @option options
    # @param association [Symbol] name of the association to decorate (e.g. `:products`).
    # @param options [Hash] a customizable set of options
    # @return [void]
    def decorates_association(association, options = T.unsafe(nil)); end

    # @overload decorates_associations
    def decorates_associations(*associations); end

    # Automatically decorates ActiveRecord finder methods, so that you can use
    # `ProductDecorator.find(id)` instead of
    # `ProductDecorator.decorate(Product.find(id))`.
    #
    # Finder methods are applied to the {object_class}.
    #
    # @return [void]
    def decorates_finders; end

    # Automatically delegates instance methods to the source object. Class
    # methods will be delegated to the {object_class}, if it is set.
    #
    # @return [void]
    def delegate_all; end

    def include_root_in_json; end
    def include_root_in_json=(value); end
    def include_root_in_json?; end

    # @raise [Draper::UninferrableObjectError]
    def inferred_object_class; end

    # @private
    def inherited(subclass); end

    def model_name(*_arg0, **_arg1, &_arg2); end

    # Returns the source class corresponding to the decorator class, as set by
    # {decorates}, or as inferred from the decorator class name (e.g.
    # `ProductDecorator` maps to `Product`).
    #
    # @return [Class] the source class that corresponds to this decorator.
    def object_class; end

    # Checks whether this decorator class has a corresponding {object_class}.
    #
    # @return [Boolean]
    def object_class?; end

    def object_class_name; end
  end
end

module Draper::Delegation
  # @overload delegate
  def delegate(*methods); end
end

class Draper::Factory
  # Creates a decorator factory.
  #
  # @option options
  # @option options
  # @param options [Hash] a customizable set of options
  # @return [Factory] a new instance of Factory
  def initialize(options = T.unsafe(nil)); end

  # Decorates an object, inferring whether to create a singular or collection
  # decorator from the type of object passed.
  #
  # @option options
  # @option options
  # @param object [Object] object to decorate.
  # @param options [Hash] a customizable set of options
  # @return [Decorator, CollectionDecorator] the decorated object.
  def decorate(object, options = T.unsafe(nil)); end

  private

  # Returns the value of attribute decorator_class.
  def decorator_class; end

  # Returns the value of attribute default_options.
  def default_options; end
end

# @private
class Draper::Factory::Worker
  # @return [Worker] a new instance of Worker
  def initialize(decorator_class, object); end

  def call(options); end

  # @raise [Draper::UninferrableDecoratorError]
  def decorator; end

  private

  # @return [Boolean]
  def collection?; end

  # @return [Boolean]
  def decoratable?; end

  # Returns the value of attribute decorator_class.
  def decorator_class; end

  def decorator_method(klass); end

  # Returns the value of attribute object.
  def object; end

  def object_decorator; end
  def update_context(options); end
end

# Provides automatically-decorated finder methods for your decorators. You
# do not have to extend this module directly; it is extended by
# {Decorator.decorates_finders}.
module Draper::Finders
  def all(options = T.unsafe(nil)); end
  def find(id, options = T.unsafe(nil)); end
  def first(options = T.unsafe(nil)); end
  def last(options = T.unsafe(nil)); end

  # Decorates dynamic finder methods (`find_all_by_` and friends).
  def method_missing(method, *args, &block); end
end

# Provides access to helper methods - both Rails built-in helpers, and those
# defined in your application.
class Draper::HelperProxy
  # @overload initialize
  # @return [HelperProxy] a new instance of HelperProxy
  def initialize(view_context); end

  def capture(*_arg0, **_arg1, &_arg2); end
  def method_missing(method, *args, **_arg2, &block); end

  protected

  # Returns the value of attribute view_context.
  def view_context; end

  private

  # Checks if the context responds to an instance method, or is able to
  # proxy it to the view context.
  #
  # @return [Boolean]
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end

  class << self
    def define_proxy(name); end
  end
end

module Draper::HelperSupport
  def decorate(input, &block); end
end

# Include this module in your decorators to get direct access to the helpers
# so that you can stop typing `h.` everywhere, at the cost of mixing in a
# bazillion methods.
module Draper::LazyHelpers
  def method_missing(method, *args, **_arg2, &block); end
end

module Draper::QueryMethods
  def method_missing(method, *args, **_arg2, &block); end

  private

  # @return [Boolean]
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end

  # Configures the strategy used to proxy the query methods, which defaults to `:active_record`.
  def strategy; end
end

module Draper::QueryMethods::LoadStrategy
  class << self
    def new(name); end
  end
end

class Draper::QueryMethods::LoadStrategy::ActiveRecord
  # @return [Boolean]
  def allowed?(method); end
end

class Draper::QueryMethods::LoadStrategy::Mongoid
  # @raise [NotImplementedError]
  # @return [Boolean]
  def allowed?(method); end
end

class Draper::Railtie < ::Rails::Railtie
  def initialize_view_context; end
end

class Draper::UninferrableDecoratorError < ::NameError
  # @return [UninferrableDecoratorError] a new instance of UninferrableDecoratorError
  def initialize(klass); end
end

class Draper::UninferrableObjectError < ::NameError
  # @return [UninferrableObjectError] a new instance of UninferrableObjectError
  def initialize(klass); end
end

Draper::VERSION = T.let(T.unsafe(nil), String)

module Draper::ViewContext
  # Set the current controller
  def activate_draper; end

  # Hooks into a controller or mailer to save the view context in {current}.
  def view_context; end

  class << self
    # Builds a new view context for usage in tests. See {test_strategy} for
    # details of how the view context is built.
    def build; end

    # Builds a new view context and sets it as the current view context.
    #
    # @return [HelperProxy]
    def build!; end

    # @private
    def build_strategy; end

    # Clears the saved controller and view context.
    def clear!; end

    # Returns the current controller.
    def controller; end

    # Sets the current controller. Clears view context when we are setting
    # different controller.
    def controller=(controller); end

    # Returns the current view context, or builds one if none is saved.
    #
    # @return [HelperProxy]
    def current; end

    # Sets the current view context.
    def current=(view_context); end

    # Configures the strategy used to build view contexts in tests, which
    # defaults to `:full` if `test_strategy` has not been called. Evaluates
    # the block, if given, in the context of the view context's class.
    #
    # @example Pass a block to add helper methods to the view context:
    #   Draper::ViewContext.test_strategy :fast do
    #   include ApplicationHelper
    #   end
    # @param name [:full, :fast] the strategy to use:
    #
    #   `:full` - build a fully-working view context. Your Rails environment
    #   must be loaded, including your `ApplicationController`.
    #
    #   `:fast` - build a minimal view context in tests, with no dependencies
    #   on other components of your application.
    def test_strategy(name, &block); end
  end
end

# @private
module Draper::ViewContext::BuildStrategy
  class << self
    def new(name, &block); end
  end
end

class Draper::ViewContext::BuildStrategy::Fast
  # @return [Fast] a new instance of Fast
  def initialize(&block); end

  def call; end

  private

  # Returns the value of attribute view_context_class.
  def view_context_class; end
end

class Draper::ViewContext::BuildStrategy::Full
  # @return [Full] a new instance of Full
  def initialize(&block); end

  def call; end

  private

  # Returns the value of attribute block.
  def block; end

  def controller; end
  def is_above_rails_5_1; end
  def new_test_request(controller); end
end

# Provides the {#helpers} method used in {Decorator} and {CollectionDecorator}
# to call the Rails helpers.
module Draper::ViewHelpers
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Draper::ViewHelpers::ClassMethods

  # Access the helpers proxy to call built-in and user-defined
  # Rails helpers. Aliased to `h` for convenience.
  #
  # @return [HelperProxy] the helpers proxy
  def h; end

  # Access the helpers proxy to call built-in and user-defined
  # Rails helpers. Aliased to `h` for convenience.
  #
  # @return [HelperProxy] the helpers proxy
  def helpers; end

  def l(*args, **_arg1); end
  def localize(*args, **_arg1); end
end

module Draper::ViewHelpers::ClassMethods
  # Access the helpers proxy to call built-in and user-defined
  # Rails helpers from a class context.
  #
  # @return [HelperProxy] the helpers proxy
  def h; end

  # Access the helpers proxy to call built-in and user-defined
  # Rails helpers from a class context.
  #
  # @return [HelperProxy] the helpers proxy
  def helpers; end
end
