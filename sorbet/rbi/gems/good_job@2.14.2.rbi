# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `good_job` gem.
# Please instead update this file by running `bin/tapioca gem good_job`.

module ActiveJob
  extend ::ActiveSupport::Autoload

  class << self
    # Returns the version of the currently loaded Active Job as a <tt>Gem::Version</tt>
    def gem_version; end

    # Returns the version of the currently loaded Active Job as a <tt>Gem::Version</tt>
    def version; end
  end
end

module ActiveJob::QueueAdapters
  extend ::ActiveSupport::Autoload

  class << self
    # Returns adapter for specified name.
    #
    #   ActiveJob::QueueAdapters.lookup(:sidekiq)
    #   # => ActiveJob::QueueAdapters::SidekiqAdapter
    def lookup(name); end
  end
end

# See {GoodJob::Adapter} for details.
class ActiveJob::QueueAdapters::GoodJobAdapter < ::GoodJob::Adapter; end

# GoodJob is a multithreaded, Postgres-based, ActiveJob backend for Ruby on Rails.
#
# +GoodJob+ is the top-level namespace and exposes configuration attributes.
module GoodJob
  include ::GoodJob::Dependencies
  extend ::GoodJob::Dependencies::ClassMethods

  def _active_job_loaded; end
  def _active_job_loaded=(val); end
  def _active_record_loaded; end
  def _active_record_loaded=(val); end
  def _rails_after_initialize_hook_called; end
  def _rails_after_initialize_hook_called=(val); end
  def active_record_parent_class; end
  def active_record_parent_class=(val); end
  def logger; end
  def logger=(val); end
  def on_thread_error; end
  def on_thread_error=(val); end
  def preserve_job_records; end
  def preserve_job_records=(val); end
  def retry_on_unhandled_error; end
  def retry_on_unhandled_error=(val); end

  class << self
    def _active_job_loaded; end
    def _active_job_loaded=(val); end
    def _active_record_loaded; end
    def _active_record_loaded=(val); end
    def _executables; end

    # Called with exception when a GoodJob thread raises an exception
    #
    # @param exception [Exception] Exception that was raised
    # @return [void]
    def _on_thread_error(exception); end

    def _rails_after_initialize_hook_called; end
    def _rails_after_initialize_hook_called=(val); end

    # Sends +#shutdown+ or +#restart+ to executable objects ({GoodJob::Notifier}, {GoodJob::Poller}, {GoodJob::Scheduler}, {GoodJob::MultiScheduler}, {GoodJob::CronManager})
    #
    # @param executables [Array<Notifier, Poller, Scheduler, MultiScheduler, CronManager>] Objects to shut down.
    # @param method_name [:symbol] Method to call, e.g. +:shutdown+ or +:restart+.
    # @param timeout [nil, Numeric]
    # @return [void]
    def _shutdown_all(executables, method_name = T.unsafe(nil), timeout: T.unsafe(nil)); end

    # The ActiveRecord parent class inherited by +GoodJob::Execution+ (default: +ActiveRecord::Base+).
    # Use this when using multiple databases or other custom ActiveRecord configuration.
    #
    # @example Change the base class:
    #   GoodJob.active_record_parent_class = "CustomApplicationRecord"
    # @return [ActiveRecord::Base]
    def active_record_parent_class; end

    # The ActiveRecord parent class inherited by +GoodJob::Execution+ (default: +ActiveRecord::Base+).
    # Use this when using multiple databases or other custom ActiveRecord configuration.
    #
    # @example Change the base class:
    #   GoodJob.active_record_parent_class = "CustomApplicationRecord"
    # @return [ActiveRecord::Base]
    def active_record_parent_class=(val); end

    # Deletes preserved job records.
    # By default, GoodJob deletes job records when the job is performed and this
    # method is not necessary. However, when `GoodJob.preserve_job_records = true`,
    # the jobs will be preserved in the database. This is useful when wanting to
    # analyze or inspect job performance.
    # If you are preserving job records this way, use this method regularly to
    # delete old records and preserve space in your database.
    #
    # @return [Integer] Number of jobs that were deleted.
    def cleanup_preserved_jobs(older_than: T.unsafe(nil)); end

    # The logger used by GoodJob (default: +Rails.logger+).
    # Use this to redirect logs to a special location or file.
    #
    # @example Output GoodJob logs to a file:
    #   GoodJob.logger = ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new("log/my_logs.log"))
    # @return [Logger, nil]
    def logger; end

    # The logger used by GoodJob (default: +Rails.logger+).
    # Use this to redirect logs to a special location or file.
    #
    # @example Output GoodJob logs to a file:
    #   GoodJob.logger = ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new("log/my_logs.log"))
    # @return [Logger, nil]
    def logger=(val); end

    # This callable will be called when an exception reaches GoodJob (default: +nil+).
    # It can be useful for logging errors to bug tracking services, like Sentry or Airbrake.
    #
    # @example Send errors to Sentry
    #   # config/initializers/good_job.rb
    #   GoodJob.on_thread_error = -> (exception) { Raven.capture_exception(exception) }
    # @return [Proc, nil]
    def on_thread_error; end

    # This callable will be called when an exception reaches GoodJob (default: +nil+).
    # It can be useful for logging errors to bug tracking services, like Sentry or Airbrake.
    #
    # @example Send errors to Sentry
    #   # config/initializers/good_job.rb
    #   GoodJob.on_thread_error = -> (exception) { Raven.capture_exception(exception) }
    # @return [Proc, nil]
    def on_thread_error=(val); end

    # Whether to preserve job records in the database after they have finished (default: +false+).
    # By default, GoodJob deletes job records after the job is completed successfully.
    # If you want to preserve jobs for latter inspection, set this to +true+.
    # If you want to preserve only jobs that finished with error for latter inspection, set this to +:on_unhandled_error+.
    # If +true+, you will need to clean out jobs using the +good_job cleanup_preserved_jobs+ CLI command or
    # by using +Goodjob.cleanup_preserved_jobs+.
    #
    # @return [Boolean, nil]
    def preserve_job_records; end

    # Whether to preserve job records in the database after they have finished (default: +false+).
    # By default, GoodJob deletes job records after the job is completed successfully.
    # If you want to preserve jobs for latter inspection, set this to +true+.
    # If you want to preserve only jobs that finished with error for latter inspection, set this to +:on_unhandled_error+.
    # If +true+, you will need to clean out jobs using the +good_job cleanup_preserved_jobs+ CLI command or
    # by using +Goodjob.cleanup_preserved_jobs+.
    #
    # @return [Boolean, nil]
    def preserve_job_records=(val); end

    # Stops and restarts executing jobs.
    # GoodJob does its work in pools of background threads.
    # When forking processes you should shut down these background threads before forking, and restart them after forking.
    # For example, you should use +shutdown+ and +restart+ when using async execution mode with Puma.
    # See the {file:README.md#executing-jobs-async--in-process} for more explanation and examples.
    #
    # @param timeout [Numeric, nil] Seconds to wait for active threads to finish.
    # @return [void]
    def restart(timeout: T.unsafe(nil)); end

    # Whether to re-perform a job when a type of +StandardError+ is raised to GoodJob (default: +true+).
    # If +true+, causes jobs to be re-queued and retried if they raise an instance of +StandardError+.
    # If +false+, jobs will be discarded or marked as finished if they raise an instance of +StandardError+.
    # Instances of +Exception+, like +SIGINT+, will *always* be retried, regardless of this attribute's value.
    #
    # @return [Boolean, nil]
    def retry_on_unhandled_error; end

    # Whether to re-perform a job when a type of +StandardError+ is raised to GoodJob (default: +true+).
    # If +true+, causes jobs to be re-queued and retried if they raise an instance of +StandardError+.
    # If +false+, jobs will be discarded or marked as finished if they raise an instance of +StandardError+.
    # Instances of +Exception+, like +SIGINT+, will *always* be retried, regardless of this attribute's value.
    #
    # @return [Boolean, nil]
    def retry_on_unhandled_error=(val); end

    # Stop executing jobs.
    # GoodJob does its work in pools of background threads.
    # When forking processes you should shut down these background threads before forking, and restart them after forking.
    # For example, you should use +shutdown+ and +restart+ when using async execution mode with Puma.
    # See the {file:README.md#executing-jobs-async--in-process} for more explanation and examples.
    #
    # @param timeout [nil, Numeric] Seconds to wait for actively executing jobs to finish
    #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
    #   * +-1+, the scheduler will wait until the shutdown is complete.
    #   * +0+, the scheduler will immediately shutdown and stop any active tasks.
    #   * +1..+, the scheduler will wait that many seconds before stopping any remaining active tasks.
    # @param wait [Boolean] whether to wait for shutdown
    # @return [void]
    def shutdown(timeout: T.unsafe(nil)); end

    # Tests whether jobs have stopped executing.
    #
    # @return [Boolean] whether background threads are shut down
    def shutdown?; end
  end
end

module GoodJob::ActiveJobExtensions; end

module GoodJob::ActiveJobExtensions::Concurrency
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::GoodJob::ActiveJobExtensions::Concurrency::ClassMethods

  def good_job_concurrency_key; end

  module GeneratedClassMethods
    def good_job_concurrency_config; end
    def good_job_concurrency_config=(value); end
    def good_job_concurrency_config?; end
  end

  module GeneratedInstanceMethods; end
end

module GoodJob::ActiveJobExtensions::Concurrency::ClassMethods
  def good_job_control_concurrency_with(config); end
end

class GoodJob::ActiveJobExtensions::Concurrency::ConcurrencyExceededError < ::StandardError
  def backtrace; end
end

# ActiveRecord model that represents an +ActiveJob+ job.
# There is not a table in the database whose discrete rows represents "Jobs".
# The +good_jobs+ table is a table of individual {GoodJob::Execution}s that share the same +active_job_id+.
# A single row from the +good_jobs+ table of executions is fetched to represent an ActiveJobJob
class GoodJob::ActiveJobJob < ::GoodJob::BaseRecord
  include ::GoodJob::ActiveJobJob::GeneratedAttributeMethods
  include ::GoodJob::ActiveJobJob::GeneratedAssociationMethods
  include ::GoodJob::Filterable
  include ::GoodJob::Lockable
  extend ::GoodJob::Filterable::ClassMethods
  extend ::GoodJob::Lockable::ClassMethods

  # Utility method to determine which execution record is used to represent this job
  #
  # @return [String]
  def _execution_id; end

  # Utility method to test whether this job's underlying attributes represents its most recent execution.
  #
  # @return [Boolean]
  def _head?; end

  def advisory_lockable_function; end
  def advisory_lockable_function=(_arg0); end
  def advisory_lockable_function?; end
  def autosave_associated_records_for_executions(*args); end
  def create_with_advisory_lock; end
  def create_with_advisory_lock=(_arg0); end

  # Discard a job so that it will not be executed further.
  # This action will add a {DiscardJobError} to the job's {Execution} and mark it as finished.
  #
  # @return [void]
  def discard_job(message); end

  # The number of times this job has been executed, according to ActiveJob's serialized state.
  #
  # @return [Numeric]
  def executions_count; end

  # This job's most recent {Execution}
  #
  # @param reload [Booelan] whether to reload executions
  # @return [Execution]
  def head_execution(reload: T.unsafe(nil)); end

  # The job's ActiveJob UUID
  #
  # @return [String]
  def id; end

  # The ActiveJob job class, as a string
  #
  # @return [String]
  def job_class; end

  # The number of times this job has been executed, according to the number of GoodJob {Execution} records.
  #
  # @return [Numeric]
  def preserved_executions_count; end

  # The most recent error message.
  # If the job has been retried, the error will be fetched from the previous {Execution} record.
  #
  # @return [String]
  def recent_error; end

  # Reschedule a scheduled job so that it executes immediately (or later) by the next available execution thread.
  #
  # @param scheduled_at [DateTime, Time] When to reschedule the job
  # @return [void]
  def reschedule_job(scheduled_at = T.unsafe(nil)); end

  # Retry a job that has errored and been discarded.
  # This action will create a new {Execution} record for the job.
  #
  # @return [ActiveJob::Base]
  def retry_job; end

  # Tests whether the job is being executed right now.
  #
  # @return [Boolean]
  def running?; end

  # The status of the Job, based on the state of its most recent execution.
  # There are 3 buckets of non-overlapping statuses:
  #   1. The job will be executed
  #     - queued: The job will execute immediately when an execution thread becomes available.
  #     - scheduled: The job is scheduled to execute in the future.
  #     - retried: The job previously errored on execution and will be re-executed in the future.
  #   2. The job is being executed
  #     - running: the job is actively being executed by an execution thread
  #   3. The job will not execute
  #     - finished: The job executed successfully
  #     - discarded: The job previously errored on execution and will not be re-executed in the future.
  #
  # @return [Symbol]
  def status; end

  # This job's initial/oldest {Execution}
  #
  # @return [Execution]
  def tail_execution; end

  def validate_associated_records_for_executions(*args); end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end
    def advisory_lock(*args, **_arg1); end
    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
    def advisory_locked(*args, **_arg1); end
    def advisory_unlocked(*args, **_arg1); end
    def default_scopes; end
    def defined_enums; end
    def discarded(*args, **_arg1); end
    def display_all(*args, **_arg1); end
    def finished(*args, **_arg1); end

    # Get Jobs finished before the given timestamp.
    #
    # @param timestamp [DateTime, Time]
    # @return [ActiveRecord::Relation]
    def finished_before(*args, **_arg1); end

    def includes_advisory_locks(*args, **_arg1); end

    # Get Jobs with given class name
    #
    # @param string [String] Execution class name
    # @return [ActiveRecord::Relation]
    def job_class(*args, **_arg1); end

    def joins_advisory_locks(*args, **_arg1); end
    def owns_advisory_locked(*args, **_arg1); end
    def queued(*args, **_arg1); end
    def retried(*args, **_arg1); end
    def running(*args, **_arg1); end
    def scheduled(*args, **_arg1); end
    def search_text(*args, **_arg1); end
    def table_name(*_arg0, **_arg1, &_arg2); end

    # @raise [NotImplementedError]
    def table_name=(_value); end
  end
end

# Raised when an inappropriate action is applied to a Job based on its state.
class GoodJob::ActiveJobJob::ActionForStateMismatchError < ::StandardError; end

# Raised when an action requires GoodJob to be the ActiveJob Queue Adapter but GoodJob is not.
class GoodJob::ActiveJobJob::AdapterNotGoodJobError < ::StandardError; end

# Attached to a Job's Execution when the Job is discarded.
class GoodJob::ActiveJobJob::DiscardJobError < ::StandardError; end

module GoodJob::ActiveJobJob::GeneratedAssociationMethods
  def execution_ids; end
  def execution_ids=(ids); end
  def executions; end
  def executions=(value); end
end

module GoodJob::ActiveJobJob::GeneratedAttributeMethods; end

# ActiveJob Adapter.
class GoodJob::Adapter
  # @param execution_mode [Symbol, nil] specifies how and where jobs should be executed. You can also set this with the environment variable +GOOD_JOB_EXECUTION_MODE+.
  #
  #   - +:inline+ executes jobs immediately in whatever process queued them (usually the web server process). This should only be used in test and development environments.
  #   - +:external+ causes the adapter to enqueue jobs, but not execute them. When using this option (the default for production environments), you'll need to use the command-line tool to actually execute your jobs.
  #   - +:async+ (or +:async_server+) executes jobs in separate threads within the Rails web server process (`bundle exec rails server`). It can be more economical for small workloads because you don't need a separate machine or environment for running your jobs, but if your web server is under heavy load or your jobs require a lot of resources, you should choose +:external+ instead.
  #   When not in the Rails web server, jobs will execute in +:external+ mode to ensure jobs are not executed within `rails console`, `rails db:migrate`, `rails assets:prepare`, etc.
  #   - +:async_all+ executes jobs in any Rails process.
  #
  #   The default value depends on the Rails environment:
  #
  #   - +development+ and +test+: +:inline+
  #   - +production+ and all other environments: +:external+
  # @param max_threads [Integer, nil] sets the number of threads per scheduler to use when +execution_mode+ is set to +:async+. The +queues+ parameter can specify a number of threads for each group of queues which will override this value. You can also set this with the environment variable +GOOD_JOB_MAX_THREADS+. Defaults to +5+.
  # @param queues [String, nil] determines which queues to execute jobs from when +execution_mode+ is set to +:async+. See {file:README.md#optimize-queues-threads-and-processes} for more details on the format of this string. You can also set this with the environment variable +GOOD_JOB_QUEUES+. Defaults to +"*"+.
  # @param poll_interval [Integer, nil] sets the number of seconds between polls for jobs when +execution_mode+ is set to +:async+. You can also set this with the environment variable +GOOD_JOB_POLL_INTERVAL+. Defaults to +1+.
  # @param start_async_on_initialize [Boolean] whether to start the async scheduler when the adapter is initialized.
  # @return [Adapter] a new instance of Adapter
  def initialize(execution_mode: T.unsafe(nil), queues: T.unsafe(nil), max_threads: T.unsafe(nil), poll_interval: T.unsafe(nil), start_async_on_initialize: T.unsafe(nil)); end

  # Whether the async executors are running
  #
  # @return [Boolean]
  def async_started?; end

  # Enqueues the ActiveJob job to be performed.
  # For use by Rails; you should generally not call this directly.
  #
  # @param active_job [ActiveJob::Base] the job to be enqueued from +#perform_later+
  # @return [GoodJob::Execution]
  def enqueue(active_job); end

  # Enqueues an ActiveJob job to be run at a specific time.
  # For use by Rails; you should generally not call this directly.
  #
  # @param active_job [ActiveJob::Base] the job to be enqueued from +#perform_later+
  # @param timestamp [Integer, nil] the epoch time to perform the job
  # @return [GoodJob::Execution]
  def enqueue_at(active_job, timestamp); end

  # Whether in +:async+ execution mode.
  #
  # @return [Boolean]
  def execute_async?; end

  # Whether in +:external+ execution mode.
  #
  # @return [Boolean]
  def execute_externally?; end

  # Whether in +:inline+ execution mode.
  #
  # @return [Boolean]
  def execute_inline?; end

  # Shut down the thread pool executors.
  #
  # @param timeout [nil, Numeric, Symbol] Seconds to wait for active threads.
  #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
  #   * +-1+, the scheduler will wait until the shutdown is complete.
  #   * +0+, the scheduler will immediately shutdown and stop any threads.
  #   * A positive number will wait that many seconds before stopping any remaining active threads.
  # @return [void]
  def shutdown(timeout: T.unsafe(nil)); end

  # Start async executors
  #
  # @return [void]
  def start_async; end

  private

  # Whether running in a web server process.
  #
  # @return [Boolean, nil]
  def in_server_process?; end

  class << self
    # List of all instantiated Adapters in the current process.
    #
    # @return [Array<GoodJob::Adapter>, nil]
    def instances; end
  end
end

# Extends an ActiveRecord odel to override the connection and use
# an explicit connection that has been removed from the pool.
module GoodJob::AssignableConnection
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::AssignableConnection::ClassMethods
end

module GoodJob::AssignableConnection::ClassMethods
  def connection; end
  def connection=(conn); end
  def with_connection(conn); end
end

# Base ActiveRecord class that all GoodJob models inherit from.
# Parent class can be configured with +GoodJob.active_record_parent_class+.
class GoodJob::BaseRecord < ::ActiveRecord::Base
  include ::GoodJob::BaseRecord::GeneratedAttributeMethods
  include ::GoodJob::BaseRecord::GeneratedAssociationMethods

  class << self
    def _validators; end
    def defined_enums; end
    def migration_pending_warning!; end
  end
end

module GoodJob::BaseRecord::GeneratedAssociationMethods; end
module GoodJob::BaseRecord::GeneratedAttributeMethods; end

# Implements the +good_job+ command-line tool, which executes jobs and
# provides other utilities. The actual entry point is in +exe/good_job+, but
# it just sets up and calls this class.
#
# The +good_job+ command-line tool is based on Thor, a CLI framework for
# Ruby. For more on general usage, see http://whatisthor.com/ and
# https://github.com/erikhuda/thor/wiki.
class GoodJob::CLI < ::Thor
  # The +good_job cleanup_preserved_jobs+ command. Deletes preserved job records.
  #
  # @return [void]
  def cleanup_preserved_jobs; end

  def set_up_application!; end

  # The +good_job start+ command. Executes queued jobs.
  #
  # @return [void]
  def start; end

  class << self
    # @return [Boolean]
    def exit_on_failure?; end

    # Whether to log to STDOUT
    #
    # @return [Boolean, nil]
    def log_to_stdout; end

    # Whether to log to STDOUT
    #
    # @return [Boolean, nil]
    def log_to_stdout=(_arg0); end

    # Whether to log to STDOUT
    #
    # @return [Boolean, nil]
    def log_to_stdout?; end

    # Whether the CLI is running from the executable
    #
    # @return [Boolean, nil]
    def within_exe; end

    # Whether the CLI is running from the executable
    #
    # @return [Boolean, nil]
    def within_exe=(_arg0); end

    # Whether the CLI is running from the executable
    #
    # @return [Boolean, nil]
    def within_exe?; end
  end
end

# Path to the local Rails application's environment configuration.
# Requiring this loads the application's configuration and classes.
GoodJob::CLI::RAILS_ENVIRONMENT_RB = T.let(T.unsafe(nil), String)

# Tracks thresholds for cleaning up old jobs.
class GoodJob::CleanupTracker
  # @return [CleanupTracker] a new instance of CleanupTracker
  def initialize(cleanup_interval_seconds: T.unsafe(nil), cleanup_interval_jobs: T.unsafe(nil)); end

  # Whether a cleanup should be run.
  #
  # @return [Boolean]
  def cleanup?; end

  # Returns the value of attribute cleanup_interval_jobs.
  def cleanup_interval_jobs; end

  # Sets the attribute cleanup_interval_jobs
  #
  # @param value the value to set the attribute cleanup_interval_jobs to.
  def cleanup_interval_jobs=(_arg0); end

  # Returns the value of attribute cleanup_interval_seconds.
  def cleanup_interval_seconds; end

  # Sets the attribute cleanup_interval_seconds
  #
  # @param value the value to set the attribute cleanup_interval_seconds to.
  def cleanup_interval_seconds=(_arg0); end

  # Increments job count.
  #
  # @return [void]
  def increment; end

  # Returns the value of attribute job_count.
  def job_count; end

  # Sets the attribute job_count
  #
  # @param value the value to set the attribute job_count to.
  def job_count=(_arg0); end

  # Returns the value of attribute last_at.
  def last_at; end

  # Sets the attribute last_at
  #
  # @param value the value to set the attribute last_at to.
  def last_at=(_arg0); end

  # Resets the counters.
  #
  # @return [void]
  def reset; end
end

# +GoodJob::Configuration+ provides normalized configuration information to
# the rest of GoodJob. It combines environment information with explicitly
# set options to get the final values for each option.
class GoodJob::Configuration
  # @param options [Hash] Any explicitly specified configuration options to
  #   use. Keys are symbols that match the various methods on this class.
  # @param env [Hash] A +Hash+ from which to read environment variables that
  #   might specify additional configuration values.
  # @return [Configuration] a new instance of Configuration
  def initialize(options, env: T.unsafe(nil)); end

  # Number of jobs a {Scheduler} will execute before cleaning up preserved jobs.
  #
  # @return [Integer, nil]
  def cleanup_interval_jobs; end

  # Number of seconds a {Scheduler} will wait before cleaning up preserved jobs.
  #
  # @return [Integer, nil]
  def cleanup_interval_seconds; end

  # Number of seconds to preserve jobs when using the +good_job cleanup_preserved_jobs+ CLI command.
  # This configuration is only used when {GoodJob.preserve_job_records} is +true+.
  #
  # @return [Integer]
  def cleanup_preserved_jobs_before_seconds_ago; end

  def cron; end
  def cron_entries; end

  # Tests whether to daemonize the process.
  #
  # @return [Boolean]
  def daemonize?; end

  # Whether to run cron
  #
  # @return [Boolean]
  def enable_cron; end

  # Whether to run cron
  #
  # @return [Boolean]
  def enable_cron?; end

  # The environment from which to read GoodJob's environment variables. By
  # default, this is the current process's environment, but it can be set
  # to something else in {#initialize}.
  #
  # @return [Hash]
  def env; end

  # Specifies how and where jobs should be executed. See {Adapter#initialize}
  # for more details on possible values.
  #
  # @return [Symbol]
  def execution_mode; end

  # The maximum number of future-scheduled jobs to store in memory.
  # Storing future-scheduled jobs in memory reduces execution latency
  # at the cost of increased memory usage. 10,000 stored jobs = ~20MB.
  #
  # @return [Integer]
  def max_cache; end

  # Indicates the number of threads to use per {Scheduler}. Note that
  # {#queue_string} may provide more specific thread counts to use with
  # individual schedulers.
  #
  # @return [Integer]
  def max_threads; end

  # The options that were explicitly set when initializing +Configuration+.
  #
  # @return [Hash]
  def options; end

  # Path of the pidfile to create when running as a daemon.
  #
  # @return [Pathname, String]
  def pidfile; end

  # The number of seconds between polls for jobs. GoodJob will execute jobs
  # on queues continuously until a queue is empty, at which point it will
  # poll (using this interval) for new queued jobs to execute.
  #
  # @return [Integer]
  def poll_interval; end

  # Port of the probe server
  #
  # @return [nil, Integer]
  def probe_port; end

  # Describes which queues to execute jobs from and how those queues should
  # be grouped into {Scheduler} instances. See
  # {file:README.md#optimize-queues-threads-and-processes} for more details
  # on the format of this string.
  #
  # @return [String]
  def queue_string; end

  # The number of seconds to wait for jobs to finish when shutting down
  # before stopping the thread. +-1+ is forever.
  #
  # @return [Numeric]
  def shutdown_timeout; end

  # @raise [ArgumentError]
  def validate!; end

  private

  def rails_config; end
end

# Default number of seconds to preserve jobs for {CLI#cleanup_preserved_jobs} and {GoodJob.cleanup_preserved_jobs}
GoodJob::Configuration::DEFAULT_CLEANUP_PRESERVED_JOBS_BEFORE_SECONDS_AGO = T.let(T.unsafe(nil), Integer)

# Default poll interval for async in development environment
GoodJob::Configuration::DEFAULT_DEVELOPMENT_ASYNC_POLL_INTERVAL = T.let(T.unsafe(nil), Integer)

# Default number of threads to use per {Scheduler}
GoodJob::Configuration::DEFAULT_MAX_CACHE = T.let(T.unsafe(nil), Integer)

# Default number of threads to use per {Scheduler}
GoodJob::Configuration::DEFAULT_MAX_THREADS = T.let(T.unsafe(nil), Integer)

# Default number of seconds between polls for jobs
GoodJob::Configuration::DEFAULT_POLL_INTERVAL = T.let(T.unsafe(nil), Integer)

# Default to always wait for jobs to finish for {Adapter#shutdown}
GoodJob::Configuration::DEFAULT_SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Valid execution modes.
GoodJob::Configuration::EXECUTION_MODES = T.let(T.unsafe(nil), Array)

# A CronEntry represents a single scheduled item's properties.
class GoodJob::CronEntry
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::API
  include ::ActiveModel::Model
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveModel::Conversion::ClassMethods

  # @raise [ArgumentError]
  # @return [CronEntry] a new instance of CronEntry
  def initialize(params = T.unsafe(nil)); end

  def __callbacks; end
  def __callbacks?; end
  def _run_validate_callbacks(&block); end
  def _validate_callbacks; end
  def _validators; end
  def _validators?; end
  def args; end
  def cron; end
  def description; end
  def display_properties; end
  def enqueue(cron_at = T.unsafe(nil)); end
  def fugit; end
  def id; end
  def job_class; end
  def jobs; end
  def key; end
  def kwargs; end
  def last_at; end
  def last_job; end
  def model_name(*_arg0, **_arg1, &_arg2); end
  def next_at; end

  # Returns the value of attribute params.
  def params; end

  def schedule; end
  def set; end
  def to_param; end
  def validation_context; end

  private

  def args_value; end
  def display_property(value); end
  def kwargs_value; end
  def set_value; end
  def validation_context=(_arg0); end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validate_callbacks; end
    def _validate_callbacks=(value); end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
    def all(configuration: T.unsafe(nil)); end
    def find(key, configuration: T.unsafe(nil)); end
  end
end

# CronManagers enqueue jobs on a repeating schedule.
class GoodJob::CronManager
  # @param cron_entries [Array<CronEntry>]
  # @param start_on_initialize [Boolean]
  # @return [CronManager] a new instance of CronManager
  def initialize(cron_entries = T.unsafe(nil), start_on_initialize: T.unsafe(nil)); end

  # Enqueues a scheduled task
  #
  # @param cron_entry [CronEntry] the CronEntry object to schedule
  def create_task(cron_entry); end

  # Execution configuration to be scheduled
  #
  # @return [Hash]
  def cron_entries; end

  # Stop and restart
  #
  # @param timeout [Numeric, nil] Unused but retained for compatibility
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the manager is running.
  #
  # @return [Boolean, nil]
  def running?; end

  # Stop/cancel any scheduled tasks
  #
  # @param timeout [Numeric, nil] Unused but retained for compatibility
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the manager is shutdown.
  #
  # @return [Boolean, nil]
  def shutdown?; end

  # Schedule tasks that will enqueue jobs based on their schedule
  def start; end

  class << self
    # List of all instantiated CronManagers in the current process.
    #
    # @return [Array<GoodJob::CronManager>, nil]
    def instances; end

    # Task observer for cron task
    #
    # @param time [Time]
    # @param output [Object]
    # @param thread_error [Exception]
    def task_observer(time, output, thread_error); end
  end
end

# Thread-local attributes for passing values from Instrumentation.
# (Cannot use ActiveSupport::CurrentAttributes because ActiveJob resets it)
module GoodJob::CurrentThread
  def cron_at; end
  def cron_at=(obj); end
  def cron_key; end
  def cron_key=(obj); end
  def error_on_discard; end
  def error_on_discard=(obj); end
  def error_on_retry; end
  def error_on_retry=(obj); end
  def execution; end
  def execution=(obj); end

  class << self
    # @return [String] UUID of the currently executing GoodJob::Execution
    def active_job_id; end

    # Cron At
    #
    # @return [DateTime, nil]
    def cron_at; end

    # Cron At
    #
    # @return [DateTime, nil]
    def cron_at=(obj); end

    # Cron Key
    #
    # @return [String, nil]
    def cron_key; end

    # Cron Key
    #
    # @return [String, nil]
    def cron_key=(obj); end

    # Error captured by discard_on
    #
    # @return [Exception, nil]
    def error_on_discard; end

    # Error captured by discard_on
    #
    # @return [Exception, nil]
    def error_on_discard=(obj); end

    # Error captured by retry_on
    #
    # @return [Exception, nil]
    def error_on_retry; end

    # Error captured by retry_on
    #
    # @return [Exception, nil]
    def error_on_retry=(obj); end

    def execution; end
    def execution=(obj); end

    # @return [Integer] Current process ID
    def process_id; end

    # Resets attributes
    #
    # @param values [Hash] to assign
    # @return [void]
    def reset(values = T.unsafe(nil)); end

    # @return [String] Current thread name
    def thread_name; end

    # Exports values to hash
    #
    # @return [Hash]
    def to_h; end

    # Wrap the yielded block with CurrentThread values and reset after the block
    #
    # @return [void]
    # @yield [self]
    def within; end
  end
end

# Resettable accessors for thread-local values.
GoodJob::CurrentThread::ACCESSORS = T.let(T.unsafe(nil), Array)

GoodJob::DEFAULT_LOGGER = T.let(T.unsafe(nil), ActiveSupport::Logger)

# Manages daemonization of the current process.
class GoodJob::Daemon
  # @param pidfile [Pathname, String] Pidfile path
  # @return [Daemon] a new instance of Daemon
  def initialize(pidfile:); end

  # Daemonizes the current process and writes out a pidfile.
  #
  # @return [void]
  def daemonize; end

  # The path of the generated pidfile.
  #
  # @return [Pathname, String]
  def pidfile; end

  private

  # @return [void]
  def check_pid; end

  # @return [void]
  def delete_pid; end

  # @param pidfile [Pathname, String]
  # @return [Symbol]
  def pid_status(pidfile); end

  # @return [void]
  def write_pid; end
end

# Extends GoodJob module to track Rails boot dependencies.
module GoodJob::Dependencies
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::Dependencies::ClassMethods
end

module GoodJob::Dependencies::ClassMethods
  def async_ready?; end
  def start_async_adapters; end
end

# ActiveRecord model that represents an +ActiveJob+ job.
class GoodJob::Execution < ::GoodJob::BaseRecord
  include ::GoodJob::Execution::GeneratedAttributeMethods
  include ::GoodJob::Execution::GeneratedAssociationMethods
  include ::GoodJob::Lockable
  include ::GoodJob::Filterable
  extend ::GoodJob::Lockable::ClassMethods
  extend ::GoodJob::Filterable::ClassMethods

  def active_job; end
  def advisory_lockable_function; end
  def advisory_lockable_function=(_arg0); end
  def advisory_lockable_function?; end
  def autosave_associated_records_for_job(*args); end
  def create_with_advisory_lock; end
  def create_with_advisory_lock=(_arg0); end

  # Tests whether this job is safe to be executed by this thread.
  #
  # @return [Boolean]
  def executable?; end

  # Execute the ActiveJob job this {Execution} represents.
  #
  # @raise [PreviouslyPerformedError]
  # @return [ExecutionResult] An array of the return value of the job's +#perform+ method and the
  #   exception raised by the job, if any. If the job completed successfully,
  #   the second array entry (the exception) will be +nil+ and vice versa.
  def perform; end

  private

  def active_job_data; end

  # @return [ExecutionResult]
  def execute; end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end

    # Get Jobs with given ActiveJob ID
    #
    # @param active_job_id [String] ActiveJob ID
    # @return [ActiveRecord::Relation]
    def active_job_id(*args, **_arg1); end

    def advisory_lock(*args, **_arg1); end
    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
    def advisory_locked(*args, **_arg1); end
    def advisory_unlocked(*args, **_arg1); end
    def dead(*args, **_arg1); end
    def defined_enums; end
    def display_all(*args, **_arg1); end

    # Places an ActiveJob job on a queue by creating a new {Execution} record.
    #
    # @param active_job [ActiveJob::Base] The job to enqueue.
    # @param scheduled_at [Float] Epoch timestamp when the job should be executed.
    # @param create_with_advisory_lock [Boolean] Whether to establish a lock on the {Execution} record after it is created.
    # @return [Execution] The new {Execution} instance representing the queued ActiveJob job.
    def enqueue(active_job, scheduled_at: T.unsafe(nil), create_with_advisory_lock: T.unsafe(nil)); end

    # Get Jobs were completed before the given timestamp. If no timestamp is
    # provided, get all jobs that have been completed. By default, GoodJob
    # deletes jobs after they are completed and this will find no jobs.
    # However, if you have changed {GoodJob.preserve_job_records}, this may
    # find completed Jobs.
    #
    # @param timestamp [Float] Get jobs that finished before this time (in epoch time).
    # @return [ActiveRecord::Relation]
    def finished(*args, **_arg1); end

    def head(*args, **_arg1); end
    def includes_advisory_locks(*args, **_arg1); end

    # Get Jobs with given class name
    #
    # @param string [String] Execution class name
    # @return [ActiveRecord::Relation]
    def job_class(*args, **_arg1); end

    def joins_advisory_locks(*args, **_arg1); end

    # Fetches the scheduled execution time of the next eligible Execution(s).
    #
    # @param after [DateTime]
    # @param limit [Integer]
    # @param now_limit [Integer, nil]
    # @return [Array<DateTime>]
    def next_scheduled_at(after: T.unsafe(nil), limit: T.unsafe(nil), now_limit: T.unsafe(nil)); end

    # Get Jobs that are not scheduled for a later time than now (i.e. jobs that
    # are not scheduled or scheduled for earlier than the current time).
    #
    # @return [ActiveRecord::Relation]
    def only_scheduled(*args, **_arg1); end

    def owns_advisory_locked(*args, **_arg1); end

    # Finds the next eligible Execution, acquire an advisory lock related to it, and
    # executes the job.
    #
    # @return [ExecutionResult, nil] If a job was executed, returns an array with the {Execution} record, the
    #   return value for the job's +#perform+ method, and the exception the job
    #   raised, if any (if the job raised, then the second array entry will be
    #   +nil+). If there were no jobs to execute, returns +nil+.
    def perform_with_advisory_lock; end

    # Order jobs by priority (highest priority first).
    #
    # @return [ActiveRecord::Relation]
    def priority_ordered(*args, **_arg1); end

    # Parse a string representing a group of queues into a more readable data
    # structure.
    #
    # @example
    #   GoodJob::Execution.queue_parser('-queue1,queue2')
    #   => { exclude: [ 'queue1', 'queue2' ] }
    # @param string [String] Queue string
    # @return [Hash] How to match a given queue. It can have the following keys and values:
    #   - +{ all: true }+ indicates that all queues match.
    #   - +{ exclude: Array<String> }+ indicates the listed queue names should
    #   not match.
    #   - +{ include: Array<String> }+ indicates the listed queue names should
    #   match.
    def queue_parser(string); end

    # Get Jobs on queues that match the given queue string.
    #
    # @param string [String] A string expression describing what queues to select. See
    #   {Execution.queue_parser} or
    #   {file:README.md#optimize-queues-threads-and-processes} for more details
    #   on the format of the string. Note this only handles individual
    #   semicolon-separated segments of that string format.
    # @return [ActiveRecord::Relation]
    def queue_string(*args, **_arg1); end

    # Get Jobs have errored that will not be retried further
    #
    # @return [ActiveRecord::Relation]
    def running(*args, **_arg1); end

    # Order jobs by scheduled (unscheduled or soonest first).
    #
    # @return [ActiveRecord::Relation]
    def schedule_ordered(*args, **_arg1); end

    def search_text(*args, **_arg1); end

    # Get Jobs that have not yet been completed.
    #
    # @return [ActiveRecord::Relation]
    def unfinished(*args, **_arg1); end
  end
end

# ActiveJob jobs without a +priority+ attribute are given this priority.
GoodJob::Execution::DEFAULT_PRIORITY = T.let(T.unsafe(nil), Integer)

# ActiveJob jobs without a +queue_name+ attribute are placed on this queue.
GoodJob::Execution::DEFAULT_QUEUE_NAME = T.let(T.unsafe(nil), String)

# String separating Error Class from Error Message
GoodJob::Execution::ERROR_MESSAGE_SEPARATOR = T.let(T.unsafe(nil), String)

module GoodJob::Execution::GeneratedAssociationMethods
  def build_job(*args, &block); end
  def create_job(*args, &block); end
  def create_job!(*args, &block); end
  def job; end
  def job=(value); end
  def job_changed?; end
  def job_previously_changed?; end
  def reload_job; end
end

module GoodJob::Execution::GeneratedAttributeMethods; end

# Raised if something attempts to execute a previously completed Execution again.
class GoodJob::Execution::PreviouslyPerformedError < ::StandardError; end

# Stores the results of job execution
class GoodJob::ExecutionResult
  # @param value [Object, nil]
  # @param handled_error [Exception, nil]
  # @param unhandled_error [Exception, nil]
  # @return [ExecutionResult] a new instance of ExecutionResult
  def initialize(value:, handled_error: T.unsafe(nil), unhandled_error: T.unsafe(nil)); end

  # @return [Exception, nil]
  def handled_error; end

  # @return [Exception, nil]
  def unhandled_error; end

  # @return [Object, nil]
  def value; end
end

# Shared methods for filtering Execution/Job records from the +good_jobs+ table.
module GoodJob::Filterable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::Filterable::ClassMethods
end

module GoodJob::Filterable::ClassMethods
  def database_supports_websearch_to_tsquery?; end
end

# @deprecated Use {GoodJob::Execution} instead.
class GoodJob::Job < ::GoodJob::Execution
  include ::GoodJob::Job::GeneratedAttributeMethods
  include ::GoodJob::Job::GeneratedAssociationMethods

  class << self
    def __callbacks; end
    def _validators; end
    def defined_enums; end
  end
end

module GoodJob::Job::GeneratedAssociationMethods; end
module GoodJob::Job::GeneratedAttributeMethods; end

# JobPerformer queries the database for jobs and performs them on behalf of a
# {Scheduler}. It mainly functions as glue between a {Scheduler} and the jobs
# it should be executing.
#
# The JobPerformer must be safe to execute across multiple threads.
class GoodJob::JobPerformer
  # @param queue_string [String] Queues to execute jobs from
  # @return [JobPerformer] a new instance of JobPerformer
  def initialize(queue_string); end

  # Delete expired preserved jobs
  #
  # @return [void]
  def cleanup; end

  # A meaningful name to identify the performer in logs and for debugging.
  #
  # @return [String] The queues from which Jobs are worked
  def name; end

  # Perform the next eligible job
  #
  # @return [Object, nil] Returns job result or +nil+ if no job was found
  def next; end

  # Tests whether this performer should be used in GoodJob's current state.
  #
  # For example, state will be a LISTEN/NOTIFY message that is passed down
  # from the Notifier to the Scheduler. The Scheduler is able to ask
  # its performer "does this message relate to you?", and if not, ignore it
  # to minimize thread wake-ups, database queries, and thundering herds.
  #
  # @return [Boolean] whether the performer's {#next} method should be
  #   called in the current state.
  def next?(state = T.unsafe(nil)); end

  # The Returns timestamps of when next tasks may be available.
  #
  # @param after [DateTime, Time, nil] future jobs scheduled after this time
  # @param limit [Integer] number of future timestamps to return
  # @param now_limit [Integer] number of past timestamps to return
  # @return [Array<DateTime, Time>, nil]
  def next_at(after: T.unsafe(nil), limit: T.unsafe(nil), now_limit: T.unsafe(nil)); end

  private

  def job_query; end
  def parsed_queues; end

  # Returns the value of attribute queue_string.
  def queue_string; end
end

# Adds Postgres advisory locking capabilities to an ActiveRecord record.
# For details on advisory locks, see the Postgres documentation:
# - {https://www.postgresql.org/docs/current/explicit-locking.html#ADVISORY-LOCKS Advisory Locks Overview}
# - {https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADVISORY-LOCKS Advisory Locks Functions}
#
# @example Add this concern to a +MyRecord+ class:
#   class MyRecord < ActiveRecord::Base
#   include Lockable
#
#   def my_method
#   ...
#   end
#   end
module GoodJob::Lockable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::GoodJob::Lockable::ClassMethods

  # Acquires an advisory lock on this record if it is not already locked by
  # another database session. Be careful to ensure you release the lock when
  # you are done with {#advisory_unlock} (or {#advisory_unlock!} to release
  # all remaining locks).
  #
  # @param key [String, Symbol] Key to Advisory Lock against
  # @param function [String, Symbol] Postgres Advisory Lock function name to use
  # @return [Boolean] whether the lock was acquired.
  def advisory_lock(key: T.unsafe(nil), function: T.unsafe(nil)); end

  # Acquires an advisory lock on this record or raises
  # {RecordAlreadyAdvisoryLockedError} if it is already locked by another
  # database session.
  #
  # @param key [String, Symbol] Key to lock against
  # @param function [String, Symbol] Postgres Advisory Lock function name to use
  # @raise [RecordAlreadyAdvisoryLockedError]
  # @return [Boolean] +true+
  def advisory_lock!(key: T.unsafe(nil), function: T.unsafe(nil)); end

  # Tests whether this record has an advisory lock on it.
  #
  # @param key [String, Symbol] Key to test lock against
  # @return [Boolean]
  def advisory_locked?(key: T.unsafe(nil)); end

  # Releases an advisory lock on this record if it is locked by this database
  # session. Note that advisory locks stack, so you must call
  # {#advisory_unlock} and {#advisory_lock} the same number of times.
  #
  # @param key [String, Symbol] Key to lock against
  # @param function [String, Symbol] Postgres Advisory Lock function name to use
  # @return [Boolean] whether the lock was released.
  def advisory_unlock(key: T.unsafe(nil), function: T.unsafe(nil)); end

  # Releases all advisory locks on the record that are held by the current
  # database session.
  #
  # @param key [String, Symbol] Key to lock against
  # @param function [String, Symbol] Postgres Advisory Lock function name to use
  # @return [void]
  def advisory_unlock!(key: T.unsafe(nil), function: T.unsafe(nil)); end

  # Tests whether this record does not have an advisory lock on it.
  #
  # @param key [String, Symbol] Key to test lock against
  # @return [Boolean]
  def advisory_unlocked?(key: T.unsafe(nil)); end

  # Default Advisory Lock key for column-based locking
  #
  # @return [String]
  def lockable_column_key(column: T.unsafe(nil)); end

  # Default Advisory Lock key
  #
  # @return [String]
  def lockable_key; end

  # Tests whether this record is locked by the current database session.
  #
  # @param key [String, Symbol] Key to test lock against
  # @return [Boolean]
  def owns_advisory_lock?(key: T.unsafe(nil)); end

  def pg_or_jdbc_query(*_arg0, **_arg1, &_arg2); end

  # Acquires an advisory lock on this record and safely releases it after the
  # passed block is completed. If the record is locked by another database
  # session, this raises {RecordAlreadyAdvisoryLockedError}.
  #
  # @example
  #   record = MyLockableRecord.first
  #   record.with_advisory_lock do
  #   do_something_with record
  #   end
  # @param key [String, Symbol] Key to lock against
  # @param function [String, Symbol] Postgres Advisory Lock function name to use
  # @raise [ArgumentError]
  # @return [Object] The result of the block.
  # @yield Nothing
  def with_advisory_lock(key: T.unsafe(nil), function: T.unsafe(nil)); end

  module GeneratedClassMethods
    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
  end

  module GeneratedInstanceMethods
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
  end
end

module GoodJob::Lockable::ClassMethods
  def _advisory_lockable_column; end
  def advisory_lock_key(key, function: T.unsafe(nil)); end
  def advisory_unlock_key(key, function: T.unsafe(nil)); end
  def advisory_unlock_session; end
  def advisory_unlockable_function(function = T.unsafe(nil)); end
  def pg_or_jdbc_query(query); end
  def supports_cte_materialization_specifiers?; end
  def with_advisory_lock(column: T.unsafe(nil), function: T.unsafe(nil), unlock_session: T.unsafe(nil)); end
end

# Indicates an advisory lock is already held on a record by another
# database session.
class GoodJob::Lockable::RecordAlreadyAdvisoryLockedError < ::StandardError; end

# Listens to GoodJob notifications and logs them.
#
# Each method corresponds to the name of a notification. For example, when
# the {Scheduler} shuts down, it sends a notification named
# +"scheduler_shutdown.good_job"+ and the {#scheduler_shutdown} method will
# be called here. See the
# {https://api.rubyonrails.org/classes/ActiveSupport/LogSubscriber.html ActiveSupport::LogSubscriber}
# documentation for more.
class GoodJob::LogSubscriber < ::ActiveSupport::LogSubscriber
  # Responds to the +cleanup_preserved_jobs.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def cleanup_preserved_jobs(event); end

  # Responds to the +create.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def create(event); end

  # Responds to the +cron_manager_start.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def cron_manager_start(event); end

  def debug(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end
  def error(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end
  def fatal(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # Responds to the +finished_job_task.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def finished_job_task(event); end

  # Responds to the +finished_timer_task.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def finished_timer_task(event); end

  def info(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # Get the logger associated with this {LogSubscriber} instance.
  #
  # @return [Logger]
  def logger; end

  # Responds to the +notifier_listen.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def notifier_listen(event); end

  # Responds to the +notifier_notified.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def notifier_notified(event); end

  # Responds to the +notifier_notify_error.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def notifier_notify_error(event); end

  # Responds to the +notifier_unlisten.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def notifier_unlisten(event); end

  # Responds to the +perform_job.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def perform_job(event); end

  # Responds to the +scheduler_create_pool.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def scheduler_create_pool(event); end

  # Responds to the +scheduler_restart_pools.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def scheduler_restart_pools(event); end

  # Responds to the +scheduler_shutdown.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def scheduler_shutdown(event); end

  # Responds to the +scheduler_shutdown_start.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  def scheduler_shutdown_start(event); end

  def unknown(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end
  def warn(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  private

  # Add "GoodJob" plus any specified tags to every
  # {ActiveSupport::TaggedLogging} logger in {LogSubscriber.loggers}. Tags
  # are only applicable inside the block passed to this method.
  #
  # @return [void]
  # @yield [void]
  def tag_logger(*tags, &block); end

  class << self
    # Represents all the loggers attached to {LogSubscriber} with a single
    # logging interface. Writing to this logger is a shortcut for writing to
    # each of the loggers in {LogSubscriber.loggers}.
    #
    # @return [Logger]
    def logger; end

    # Tracks all loggers that {LogSubscriber} is writing to. You can write to
    # multiple logs by appending to this array. After updating it, you should
    # usually call {LogSubscriber.reset_logger} to make sure they are all
    # written to.
    #
    # Defaults to {GoodJob.logger}.
    #
    # @example Write to STDOUT and to a file:
    #   GoodJob::LogSubscriber.loggers << ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new(STDOUT))
    #   GoodJob::LogSubscriber.loggers << ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new("log/my_logs.log"))
    #   GoodJob::LogSubscriber.reset_logger
    # @return [Array<Logger>]
    def loggers; end

    # Reset {LogSubscriber.logger} and force it to rebuild a new shortcut to
    # all the loggers in {LogSubscriber.loggers}. You should usually call
    # this after modifying the {LogSubscriber.loggers} array.
    #
    # @return [void]
    def reset_logger; end
  end
end

# Delegates the interface of a single {Scheduler} to multiple Schedulers.
class GoodJob::MultiScheduler
  # @param schedulers [Array<Scheduler>]
  # @return [MultiScheduler] a new instance of MultiScheduler
  def initialize(schedulers); end

  # Delegates to {Scheduler#create_thread}.
  #
  # @param state [Hash]
  # @return [Boolean, nil]
  def create_thread(state = T.unsafe(nil)); end

  # Delegates to {Scheduler#restart}.
  #
  # @param timeout [Numeric, nil]
  # @return [void]
  def restart(timeout: T.unsafe(nil)); end

  # Delegates to {Scheduler#running?}.
  #
  # @return [Boolean, nil]
  def running?; end

  # @return [Array<Scheduler>] List of the scheduler delegates
  def schedulers; end

  # Delegates to {Scheduler#shutdown}.
  #
  # @param timeout [Numeric, nil]
  # @return [void]
  def shutdown(timeout: T.unsafe(nil)); end

  # Delegates to {Scheduler#shutdown?}.
  #
  # @return [Boolean, nil]
  def shutdown?; end
end

# Notifiers hook into Postgres LISTEN/NOTIFY functionality to emit and listen for notifications across processes.
#
# Notifiers can emit NOTIFY messages through Postgres.
# A notifier will LISTEN for messages by creating a background thread that runs in an instance of +Concurrent::ThreadPoolExecutor+.
# When a message is received, the notifier passes the message to each of its recipients.
class GoodJob::Notifier
  include ::ActiveSupport::Callbacks
  include ::GoodJob::Notifier::ProcessRegistration
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # @param recipients [Array<#call, Array(Object, Symbol)>]
  # @return [Notifier] a new instance of Notifier
  def initialize(*recipients); end

  def __callbacks; end
  def __callbacks?; end
  def _listen_callbacks; end
  def _run_listen_callbacks(&block); end
  def _run_unlisten_callbacks(&block); end
  def _unlisten_callbacks; end
  def connection; end
  def connection=(obj); end

  # Invoked on completion of ThreadPoolExecutor task
  #
  # @return [void]
  def listen_observer(_time, _result, thread_error); end

  # Tests whether the notifier is active and listening for new messages.
  #
  # @return [true, false, nil]
  def listening?; end

  # List of recipients that will receive notifications.
  #
  # @return [Array<#call, Array(Object, Symbol)>]
  def recipients; end

  # Restart the notifier.
  # When shutdown, start; or shutdown and start.
  #
  # @param timeout [nil, Numeric] Seconds to wait; shares same values as {#shutdown}.
  # @return [void]
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the notifier is running.
  #
  # @return [true, false, nil]
  def running?(*_arg0, **_arg1, &_arg2); end

  # Shut down the notifier.
  # This stops the background LISTENing thread.
  # Use {#shutdown?} to determine whether threads have stopped.
  #
  # @param timeout [Numeric, nil] Seconds to wait for active threads.
  #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
  #   * +-1+, the scheduler will wait until the shutdown is complete.
  #   * +0+, the scheduler will immediately shutdown and stop any threads.
  #   * A positive number will wait that many seconds before stopping any remaining active threads.
  # @return [void]
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the scheduler is shutdown.
  #
  # @return [true, false, nil]
  def shutdown?(*_arg0, **_arg1, &_arg2); end

  private

  def create_executor; end

  # Returns the value of attribute executor.
  def executor; end

  def listen(delay: T.unsafe(nil)); end
  def wait_for_notify; end
  def with_connection; end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _listen_callbacks; end
    def _listen_callbacks=(value); end
    def _unlisten_callbacks; end
    def _unlisten_callbacks=(value); end

    # ActiveRecord Connection that has been established for the Notifier.
    #
    # @return [ActiveRecord::ConnectionAdapters::AbstractAdapter, nil]
    def connection; end

    # ActiveRecord Connection that has been established for the Notifier.
    #
    # @return [ActiveRecord::ConnectionAdapters::AbstractAdapter, nil]
    def connection=(obj); end

    # List of all instantiated Notifiers in the current process.
    #
    # @return [Array<GoodJob::Notifier>, nil]
    def instances; end

    # Send a message via Postgres NOTIFY
    #
    # @param message [#to_json]
    def notify(message); end
  end
end

# Default Postgres channel for LISTEN/NOTIFY
GoodJob::Notifier::CHANNEL = T.let(T.unsafe(nil), String)

# Connection errors that will wait {RECONNECT_INTERVAL} before reconnecting
GoodJob::Notifier::CONNECTION_ERRORS = T.let(T.unsafe(nil), Array)

# Defaults for instance of Concurrent::ThreadPoolExecutor
GoodJob::Notifier::EXECUTOR_OPTIONS = T.let(T.unsafe(nil), Hash)

# Extends the Notifier to register the process in the database.
module GoodJob::Notifier::ProcessRegistration
  extend ::ActiveSupport::Concern

  # Deregisters the current process.
  def deregister_process; end

  # Registers the current process.
  def register_process; end
end

# Seconds to wait if database cannot be connected to
GoodJob::Notifier::RECONNECT_INTERVAL = T.let(T.unsafe(nil), Integer)

# Seconds to block while LISTENing for a message
GoodJob::Notifier::WAIT_INTERVAL = T.let(T.unsafe(nil), Integer)

# Pollers regularly wake up execution threads to check for new work.
class GoodJob::Poller
  # @param recipients [Array<Proc, #call, Array(Object, Symbol)>]
  # @param poll_interval [Integer, nil] number of seconds between polls
  # @return [Poller] a new instance of Poller
  def initialize(*recipients, poll_interval: T.unsafe(nil)); end

  # List of recipients that will receive notifications.
  #
  # @return [Array<#call, Array(Object, Symbol)>]
  def recipients; end

  # Restart the poller.
  # When shutdown, start; or shutdown and start.
  #
  # @param timeout [Numeric, nil] Seconds to wait; shares same values as {#shutdown}.
  # @return [void]
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the timer is running.
  #
  # @return [true, false, nil]
  def running?(*_arg0, **_arg1, &_arg2); end

  # Shut down the poller.
  # Use {#shutdown?} to determine whether threads have stopped.
  #
  # @param timeout [nil, Numeric] Seconds to wait for active threads.
  #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
  #   * +-1+, the scheduler will wait until the shutdown is complete.
  #   * +0+, the scheduler will immediately shutdown and stop any threads.
  #   * A positive number will wait that many seconds before stopping any remaining active threads.
  # @return [void]
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the timer is shutdown.
  #
  # @return [true, false, nil]
  def shutdown?; end

  # Invoked on completion of TimerTask task.
  #
  # @param time [Integer]
  # @param executed_task [Object, nil]
  # @param thread_error [Exception, nil]
  # @return [void]
  def timer_observer(time, executed_task, thread_error); end

  private

  # @return [void]
  def create_timer; end

  # @return [Concurrent::TimerTask]
  def timer; end

  class << self
    # Creates GoodJob::Poller from a GoodJob::Configuration instance.
    #
    # @param configuration [GoodJob::Configuration]
    # @return [GoodJob::Poller]
    def from_configuration(configuration); end

    # List of all instantiated Pollers in the current process.
    #
    # @return [Array<GoodJob::Poller>, nil]
    def instances; end
  end
end

# Defaults for instance of Concurrent::TimerTask.
# The timer controls how and when sleeping threads check for new work.
GoodJob::Poller::DEFAULT_TIMER_OPTIONS = T.let(T.unsafe(nil), Hash)

class GoodJob::ProbeServer
  # @return [ProbeServer] a new instance of ProbeServer
  def initialize(port:); end

  def call(env); end

  # @return [Boolean]
  def running?; end

  def start; end
  def stop; end

  class << self
    def task_observer(time, output, thread_error); end
  end
end

GoodJob::ProbeServer::RACK_SERVER = T.let(T.unsafe(nil), String)

# ActiveRecord model that represents an GoodJob process (either async or CLI).
class GoodJob::Process < ::GoodJob::BaseRecord
  include ::GoodJob::Process::GeneratedAttributeMethods
  include ::GoodJob::Process::GeneratedAssociationMethods
  include ::GoodJob::AssignableConnection
  include ::GoodJob::Lockable
  extend ::GoodJob::AssignableConnection::ClassMethods
  extend ::GoodJob::Lockable::ClassMethods

  def _connection; end
  def _connection=(obj); end
  def _current_id; end
  def _current_id=(val); end
  def _pid; end
  def _pid=(val); end
  def advisory_lockable_function; end
  def advisory_lockable_function=(_arg0); end
  def advisory_lockable_function?; end
  def create_with_advisory_lock; end
  def create_with_advisory_lock=(_arg0); end

  # Unregisters the instance.
  def deregister; end

  def mutex; end

  class << self
    def __callbacks; end
    def _connection; end
    def _connection=(obj); end
    def _current_id; end
    def _current_id=(val); end
    def _pid; end
    def _pid=(val); end
    def _validators; end

    # Processes that are inactive and unlocked (e.g. SIGKILLed)
    #
    # @return [ActiveRecord::Relation]
    def active(*args, **_arg1); end

    def advisory_lock(*args, **_arg1); end
    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
    def advisory_locked(*args, **_arg1); end
    def advisory_unlocked(*args, **_arg1); end

    # Deletes all inactive process records.
    def cleanup; end

    # UUID that is unique to the current process and changes when forked.
    #
    # @return [String]
    def current_id; end

    # Hash representing metadata about the current process.
    #
    # @return [Hash]
    def current_state; end

    def defined_enums; end
    def inactive(*args, **_arg1); end
    def includes_advisory_locks(*args, **_arg1); end
    def joins_advisory_locks(*args, **_arg1); end

    # Whether the +good_job_processes+ table exsists.
    #
    # @return [Boolean]
    def migrated?; end

    def mutex; end
    def owns_advisory_locked(*args, **_arg1); end

    # Registers the current process in the database
    #
    # @return [GoodJob::Process]
    def register; end
  end
end

module GoodJob::Process::GeneratedAssociationMethods; end
module GoodJob::Process::GeneratedAttributeMethods; end

# Ruby on Rails integration.
class GoodJob::Railtie < ::Rails::Railtie; end

# Schedulers are generic thread pools that are responsible for
# periodically checking for available tasks, executing tasks within a thread,
# and efficiently scaling active threads.
#
# Every scheduler has a single {JobPerformer} that will execute tasks.
# The scheduler is responsible for calling its performer efficiently across threads managed by an instance of +Concurrent::ThreadPoolExecutor+.
# If a performer does not have work, the thread will go to sleep.
# The scheduler maintains an instance of +Concurrent::TimerTask+, which wakes sleeping threads and causes them to check whether the performer has new work.
class GoodJob::Scheduler
  # @param performer [GoodJob::JobPerformer]
  # @param max_threads [Numeric, nil] number of seconds between polls for jobs
  # @param max_cache [Numeric, nil] maximum number of scheduled jobs to cache in memory
  # @param warm_cache_on_initialize [Boolean] whether to warm the cache immediately, or manually by calling +warm_cache+
  # @param cleanup_interval_seconds [Numeric, nil] number of seconds between cleaning up job records
  # @param cleanup_interval_jobs [Numeric, nil] number of executed jobs between cleaning up job records
  # @raise [ArgumentError]
  # @return [Scheduler] a new instance of Scheduler
  def initialize(performer, max_threads: T.unsafe(nil), max_cache: T.unsafe(nil), warm_cache_on_initialize: T.unsafe(nil), cleanup_interval_seconds: T.unsafe(nil), cleanup_interval_jobs: T.unsafe(nil)); end

  # Preload existing runnable and future-scheduled jobs
  #
  # @return [void]
  def cleanup; end

  # Wakes a thread to allow the performer to execute a task.
  #
  # @param state [Hash, nil] Contextual information for the performer. See {JobPerformer#next?}.
  # @return [Boolean, nil] Whether work was started.
  #
  #   * +nil+ if the scheduler is unable to take new work, for example if the thread pool is shut down or at capacity.
  #   * +true+ if the performer started executing work.
  #   * +false+ if the performer decides not to attempt to execute a task based on the +state+ that is passed to it.
  def create_thread(state = T.unsafe(nil)); end

  # Human readable name of the scheduler that includes configuration values.
  #
  # @return [String]
  def name; end

  # Restart the Scheduler.
  # When shutdown, start; or shutdown and start.
  #
  # @param timeout [nil, Numeric] Seconds to wait for actively executing jobs to finish; shares same values as {#shutdown}.
  # @return [void]
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the scheduler is running.
  #
  # @return [Boolean, nil]
  def running?(*_arg0, **_arg1, &_arg2); end

  # Shut down the scheduler.
  # This stops all threads in the thread pool.
  # Use {#shutdown?} to determine whether threads have stopped.
  #
  # @param timeout [Numeric, nil] Seconds to wait for actively executing jobs to finish
  #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
  #   * +-1+, the scheduler will wait until the shutdown is complete.
  #   * +0+, the scheduler will immediately shutdown and stop any active tasks.
  #   * A positive number will wait that many seconds before stopping any remaining active tasks.
  # @return [void]
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the scheduler is shutdown.
  #
  # @return [Boolean, nil]
  def shutdown?(*_arg0, **_arg1, &_arg2); end

  # Information about the Scheduler
  #
  # @return [Hash]
  def stats; end

  # Invoked on completion of ThreadPoolExecutor task
  #
  # @return [void]
  def task_observer(time, output, thread_error); end

  # Preload existing runnable and future-scheduled jobs
  #
  # @return [void]
  def warm_cache; end

  private

  def cache_count; end

  # @return [void]
  def create_executor; end

  # @param delay [Integer]
  # @return [void]
  def create_task(delay = T.unsafe(nil)); end

  # Returns the value of attribute executor.
  def executor; end

  # @param name [String]
  # @param payload [Hash]
  # @return [void]
  def instrument(name, payload = T.unsafe(nil), &block); end

  # Returns the value of attribute performer.
  def performer; end

  def remaining_cache_count; end

  # Returns the value of attribute timer_set.
  def timer_set; end

  class << self
    # Creates GoodJob::Scheduler(s) and Performers from a GoodJob::Configuration instance.
    #
    # @param configuration [GoodJob::Configuration]
    # @param warm_cache_on_initialize [Boolean]
    # @return [GoodJob::Scheduler, GoodJob::MultiScheduler]
    def from_configuration(configuration, warm_cache_on_initialize: T.unsafe(nil)); end

    # List of all instantiated Schedulers in the current process.
    #
    # @return [Array<GoodJob::Scheduler>, nil]
    def instances; end
  end
end

# Defaults for instance of Concurrent::ThreadPoolExecutor
# The thread pool executor is where work is performed.
GoodJob::Scheduler::DEFAULT_EXECUTOR_OPTIONS = T.let(T.unsafe(nil), Hash)

# Custom sub-class of +Concurrent::ThreadPoolExecutor+ to add additional worker status.
#
# @private
class GoodJob::Scheduler::ThreadPoolExecutor < ::Concurrent::ThreadPoolExecutor
  # Number of inactive threads available to execute tasks.
  # https://github.com/ruby-concurrency/concurrent-ruby/issues/684#issuecomment-427594437
  #
  # @return [Integer]
  def ready_worker_count; end
end

# Custom sub-class of +Concurrent::TimerSet+ for additional behavior.
#
# @private
class GoodJob::Scheduler::TimerSet < ::Concurrent::TimerSet
  # Number of scheduled jobs in the queue
  #
  # @return [Integer]
  def length; end

  # Clear the queue
  #
  # @return [void]
  def reset; end
end

# GoodJob gem version.
GoodJob::VERSION = T.let(T.unsafe(nil), String)
