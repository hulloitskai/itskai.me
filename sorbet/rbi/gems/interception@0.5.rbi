# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `interception` gem.
# Please instead update this file by running `bin/tapioca gem interception`.

# Provides global facility for monitoring exceptions raised in your application.
module Interception
  class << self
    # Listen for any exceptions raised.
    #
    # The listener block that you pass in will be executed as though inside Kernel#raise,
    # so your entire program is still actively running. If you have a gem like
    # pry-stack_explorer you can access the stack frames that lead to the exception
    # occurring.
    #
    # NOTE: Be careful when writing a listener, if your listener raises an
    # exception it will mask the original exception (though it will not recursively
    # call your listener).
    #
    # @example
    #
    #   # To log exceptions for the duration of a given block.
    #   def log_exceptions(&block)
    #   Interception.listen(block) do |exception, binding|
    #   puts "#{binding.eval("self.inspect")} raised #{exception.inspect}"
    #   end
    #   end
    # @example
    #
    #   # To report exceptions for the entire run of the program:
    #   Interception.listen do |exception, binding|
    #   Emailer.spam!('on-duty@startup.com', exception, binding.eval('self.class.name'))
    #   end
    # @example
    #
    #   # You can also turn listeners on and off manually
    #
    #   listener = Proc.new{ |exception, binding|
    #   binding.pry
    #   }
    #   Interception.listen(listener)
    #   Async::Redis.get("foo") do
    #   Interception.unlisten(listener)
    #   end
    # @param listen_block [Proc] The block to call when an exception occurs,
    #   takes two arguments, the exception and the
    #   binding
    # @param for_block [Proc] (nil) If you pass for_block in, then you will only
    #   intercept exceptions raised while that block
    #   is running.
    # @raise [ArgumentError]
    # @return [Object] The return value of the for_block (if present)
    # @see .unlisten
    # @yield [exception, binding]
    def listen(for_block = T.unsafe(nil), &listen_block); end

    # Returns the value of attribute listeners.
    def listeners; end

    # Sets the attribute listeners
    #
    # @param value the value to set the attribute listeners to.
    def listeners=(_arg0); end

    # Returns the value of attribute mutex.
    def mutex; end

    # Sets the attribute mutex
    #
    # @param value the value to set the attribute mutex to.
    def mutex=(_arg0); end

    # Called by platform-specific implementations whenever an exception is raised.
    #
    # The arguments will be forwarded on to all listeners added via {listen} that
    # haven't been removed via {unlisten}.
    #
    # For efficiency, this block will never be called unless there are active
    # listeners.
    #
    # @param exception [Exception] The exception that was raised
    # @param binding [Binding] The binding from which it was raised
    def rescue(exception, binding); end

    # Returns the value of attribute rescueing.
    def rescueing; end

    # Sets the attribute rescueing
    #
    # @param value the value to set the attribute rescueing to.
    def rescueing=(_arg0); end

    # Disable a previously added listener
    #
    # @param listen_block [Proc] The listen block you wish to remove.
    # @see .listen
    def unlisten(listen_block); end

    private

    # Start sending events to rescue.
    # Implemented per-platform
    #
    # @raise [NotImplementedError]
    def start; end

    # Stop sending events to rescue.
    # Implemented per-platform
    #
    # @raise [NotImplementedError]
    def stop; end
  end
end
